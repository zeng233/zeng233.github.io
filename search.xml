<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java垃圾收集器概述</title>
      <link href="/2022/12/11/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/12/11/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>java语言作为后起之秀，解决了以前手动管理内存的问题，这里面一个重要的东西就垃圾回收器，虽然开发人员不用关心内存分配问题了，但是线上运行的系统可能会有各种未知的问题，如有内存溢出、频繁的full gc等等，这里面就涉及到一些参数调整，如果不对垃圾回收器有个大概的了解，处理起来也很棘手。</p><h1 id="回收前置条件"><a href="#回收前置条件" class="headerlink" title="回收前置条件"></a>回收前置条件</h1><p>判断对象是否可回收？</p><p>1.引用计数算法</p><p>当某个对象的引用数量大于0时才是存活的，一旦引用数量为0就可以回收，java虚拟机没使用这种算法，不做解释，想研究算法的可参考《垃圾回收算法手册  自动内存管理的艺术》第五章节。</p><p>2.可达性分析算法</p><p>Hotspot虚拟机就采用此算法，如下图：</p><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/1.%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.jpg" alt></p><p>在 Java 中 GC Roots 一般包含以下内容:</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>3.finalize()方法</p><p>如果进行可达性分析回收之后，有执行finalize()方法，相当于对象发出一次自救行为，系统也自会自救一次，如果下次垃圾回收还是会把此对象回收掉。</p><p>4.常量池的回收条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>强引用：如Object obj=new Object()，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。<br>软引用：在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常，使用SoftReference实现。<br>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，使用WeakReference实现。<br>虚引用：最弱的一种引用关系，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知，使用PhantomReference实现。</p><p>#垃圾回收算法</p><ol><li>分代收集理论</li></ol><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/2.%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86.png" alt></p><p>如图所示，堆空间里面，大部分对象的生命周期都很短暂，java虚拟机针对不同的分代，采用了不同的垃圾算法。</p><ol start="2"><li>标记-清除算法</li></ol><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/3.%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt></p><p>标记可回收对象，然后统一清除。缺点：1）执行效率不稳定，如果有大量对象需要回收，需要大量的标记清理；2）会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p><ol start="2"><li>标记-复制算法</li></ol><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/4.%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt></p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。缺点：只是用了一半的内存。</p><ol start="3"><li>标记-整理算法</li></ol><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/5.%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg" alt></p><p>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="/images/2023032502java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0/6.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt></p><p>使用-XX JVM参数对应的垃圾收集器：</p><p>UseSerialGC：Serial + Serial Old；</p><p>UseParNewGC：ParNew + Serial Old；</p><p>UseConcMarkSweepGC：ParNew + CMS + Serial Old，Serial Old只是当CMS收集失败了备用的一个选择；</p><p>UseParallelGC：Parallel Scanvenge + Serial Old；</p><p>UseParallelOldGC：Parallel Scanvenge + Parallel Old；</p><p>UseG1GC:G1。</p><p>参考资料：</p><p><a href="https://docs.oracle.com/javase/10/gctuning/introduction-garbage-collection-tuning.htm" target="_blank" rel="noopener">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p><p><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版》</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM概述</title>
      <link href="/2022/12/10/2023032501JVM%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/12/10/2023032501JVM%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为什么要使用虚拟机？从编程语言的演变发展来看，开关-》二进制-》汇编-》C语言-》C++-》java，经过一层层抽象，为了跨平台，最终形成了虚拟机，其中的发展细节可以参考《编码：隐匿在计算机软硬件背后的语言》。java程序经过编译器编译，生成java字节码，再由java虚拟机加载字节码，最终生成目标代码，用户端源码不用修改就可以跨平台运行。</p><h1 id="JVM结构"><a href="#JVM结构" class="headerlink" title="JVM结构"></a>JVM结构</h1><p>jvm内部结构图：</p><p><img src="/images/2023032501JVM%E6%A6%82%E8%BF%B0/Hotspot_Architecture.jpg" alt="jvm内部结构"></p><p>红色框部分表示线程私有变量，method area、heap为线程共享部分。runtime data areas 5块内容介绍：</p><ul><li><p><strong>程序计数器（program counter register）</strong>：JVM每个线程都有自己的PC，通过PC去找到自己的执行方法，线程执行如下图所示：<br><img src="/images/2023032501JVM%E6%A6%82%E8%BF%B0/JVM2.jpeg" alt="线程执行图"></p></li><li><p><strong>JVM栈（stack）</strong>：如上图所示，在JVM线程执行方法时，在内部都有一个栈空间，栈的作用就是存储Frame结构，里面包含了各种参数（方法参数，成员变量参数，返回值参数等等）引用：<br><img src="/images/2023032501JVM%E6%A6%82%E8%BF%B0/JVM3.png" alt="JVM栈"><br>栈空间经常有两个异常是和它先关的：</p></li></ul><p>1.<strong>StackOverflowError</strong>，当执行线程的方法栈的容量大于JVM可允许的容量时，就抛出StackOverflowError（纵向比较）<br>2.<strong>OutOfMemoryError</strong>，栈内存可以动态扩展，虽然内存不足，但是允许为每个线程初始化栈空间，这时就会抛出OutOfMemoryError（横向比较）</p><ul><li><p><strong>本地方法栈（ Native Method Stacks）</strong><br>俗称”C Stack”，如果有本地方法，每个执行线程会单独的创建一个C stack。这里也有可能有两个错误异常，原因和栈空间一样。</p></li><li><p><strong>堆空间（heap）</strong><br>用于存储类实例以及数组分配的空间，JVM线程可以共享该区域。垃圾收集器回收利用对象就是在这个区域实现的。堆空间不需要连续的，内部是有向图数据结构，而栈空间是连续的。堆空间可以通过外部命令设置空间大小，如果程序运行期间堆空间的容量大于JVM设置的堆空间最大容量，就会抛出OutOfMemoryError。</p></li><li><p><strong>方法区域（Method Area）</strong><br>逻辑上是堆空间的一部分，线程也可以共享，它存储了每个类（.class）的常量、属性、方法以及构造方法，它有最大、最小空间阈值，如果方法区域空间不能满足请求分配的容量（超出最大阈值），就会抛出OutOfMemoryError。方法区内部还有一块运行时常量池（Runtime Constant Pool），编译生成的各种常量就会存到该区域，如果存储容量超过方法区的限制，也会抛出OutOfMemoryError。</p></li></ul><p>最后说下，虚拟机之外还有一块直接内存，由JDK1.4NIO引入，它通过DirectByteBuffer存储到堆内存，堆里面只是引用，实际它的大小限制是不受JVM控制的，如果这块内容大于实际物理内存也会抛出OutOfMemoryError。了解虚拟机目的是为了排查处理系统可能遇到的问题，而不是研发性质的，如果一天能花20%的时间了解虚拟机的一个大概内容，对后面JVM调优、问题排查还是很有帮助。</p><p>参考资料：<br><a href="https://book.douban.com/subject/1788390/" target="_blank" rel="noopener">《Inside the Java 2 Virtual Machine》</a><br><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈学习</title>
      <link href="/2022/08/25/20220911%E8%B0%88%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/08/25/20220911%E8%B0%88%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一.背景"></a>一.背景</h1><p>相比前几年一直埋头撸源码，去年年底通过一些总结，发现工作这么些年，却没有自己的一套学习方法论，心里不禁一颤。记得2018年的一天朋友圈看到lead发了一篇关于费曼学习法的文章，当时不以为然，慢慢的发现自己还沉浸于技术思维圈，直到去年底接触到一本关于如何学习的书，才对学习有个系统的认知，后面一连串连锁反应，激发了自己的学习动力。在翻阅电脑资料的时候，发现参加2013敏捷成都活动的几个资料，当时支付宝大佬的一次分享主题就是《终生学习》，这么硬核的东西，当时都不知道珍惜，多打脸！！！</p><h1 id="二-为什么要学"><a href="#二-为什么要学" class="headerlink" title="二.为什么要学"></a>二.为什么要学</h1><p>作为一个普通人，想要改变自己命运，只有通过不断学习，最后才有可能改变命运。面对自己所处环境，改变命运这个话有点大了，现在想想第一步还是怎么活下去，让家里人生活得更好，让自己没有中年危机感。</p><h1 id="三-如何学"><a href="#三-如何学" class="headerlink" title="三.如何学"></a>三.如何学</h1><p>关于如何学习这个主题，肯定不是我们这代人第一次遇到的，这就需要前人的智慧，只要找到适合自己的框架即可，这里就推荐下《程序员的思维修炼》中的德雷福斯模型。学习是一门系统工程，想要长期坚持下去，得有自己的学习方法论。作为系统它是由各个部分组成，可以简单粗暴的理解为输入、消化、输出，作为工程，可以类比于软件工程，它有生命周期的，前期需求调研（第一性原理，追溯根源确定目标）、学习设计（思维导图抽象子模块，该学什么）、学习过程（静默状态，二八原则）、输出结果（康奈尔笔记法）、实际运用、运维阶段（反馈修正）。俗话说：“工欲善其事，必先利其器。”，学习中如果没有框架工具，如同开发一个系统不使用框架，用原生接口来干活，那不累成狗？面对信息爆炸的时代，阅读书籍是最为推荐的（关于如何阅读，又是一个大主题，后期单独说），因为前人踩的坑，我们可以尽量避免，别人参考资料作为衍生物也可以扩展下知识面。学习这个过程想要快速落地，需要像精益创业那样，找一个最有价值的产品快速落地（也可以是简单有用的主题试水，让自己有信心，成为一种习惯，而不是把学习作为负担），然后不断迭代修正，但凡一件事儿做成了其他领域的学习就可以当成一个模板了，查理芒格曾经也说过，工程学的思维模型是地球上最可靠的思维模型。</p><h1 id="四-学什么"><a href="#四-学什么" class="headerlink" title="四.学什么"></a>四.学什么</h1><p>首先要明确学习的目标是什么，然后再定计划，专注于这个领域学习。学习的内容与自身所处环境息息相关，比如职场学习，大的学习目标往T型人才发展，需要根据已自己的专业为主线，在自己的工作年限，定制小的学习目标，针对每个小目标进行细分，找到相关资料进行学习。再实际一点，直接对标大厂相关职位需要哪些技能，如谷歌技能评分卡、阿里腾讯技术能力模型。现在网上资料繁杂，很容易迷失方向，这里需要上面的学习工具、方法论，经过一段的训练，成为一种习惯。以前自己也喜欢刷头条，后面建立了自己的知识雷达之后，感觉这些App浪费了太多时间，索性删除了这类App，把时间投入到学习中。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h1><p>总的来说，学习是一个长线投资，需要有自己的使命愿景、价值观、工具方法论，才能坚持下去。当然最终的目标都是为了“活下去”。</p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li><a href="https://book.douban.com/subject/26580132/" target="_blank" rel="noopener">《学习的本质》</a></li><li><a href="https://book.douban.com/subject/5372651/" target="_blank" rel="noopener">《程序员的思维修炼》</a></li><li><a href="https://book.douban.com/subject/26895993/" target="_blank" rel="noopener">《刻意练习》</a></li><li><a href="https://book.douban.com/subject/33391219/" target="_blank" rel="noopener">《金字塔原理》</a></li><li><a href="https://book.douban.com/subject/30354703/" target="_blank" rel="noopener">《学习力：颠覆职场学习的高效方法》</a></li><li><a href="https://book.douban.com/subject/35152777/" target="_blank" rel="noopener">《思维模型：建立高品质思维的30种模型》</a></li><li><a href="https://book.douban.com/subject/4051739/" target="_blank" rel="noopener">《第五项修炼》</a></li><li><a href="https://book.douban.com/subject/35178429/" target="_blank" rel="noopener">《学习高手》</a></li><li><a href="https://book.douban.com/subject/35059710/" target="_blank" rel="noopener">《培养你的逻辑脑》</a></li><li><a href="https://book.douban.com/subject/30094507/" target="_blank" rel="noopener">《专业的力量：在自己的领域成为专家》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> programming road </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么使用springboot</title>
      <link href="/2017/08/28/2023033101%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8springboot/"/>
      <url>/2017/08/28/2023033101%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8springboot/</url>
      
        <content type="html"><![CDATA[<p>其实最早接触springboot是在2013年底的样子，当时所在的一个研发小组就有伙伴分享过，但是也觉得挺麻烦的，各种注解搞得头晕，当时springboot1.0的release版本都没发布，也太鲜了，还有个自己对spring的研究不是特别深入，也就没去调研这个框架了。最近周边同事都在讨论老项目升级springboot，但是还是有些顾虑，一个是考虑现有业务及环境因素，还有个就是springboot把spring再封装一遍，像套娃一样，里面运行的机制是撒，这些没搞明白，其实风险也挺大的。下面就说说自己对springboot的一些看法。</p><p>先了解下springboot的历史，找到创建这个项目的源头思想。最初spring issues里面有个研发提出希望spring能搞出一个<a href="https://github.com/spring-projects/spring-framework/issues/14521" target="_blank" rel="noopener">‘containerless’ web application architectures</a>(就是让研发不用关心servlet容器)，一般我们做web应用都要发布到servlet容器，里面涉及到各种web.xml配置，还要理解ApplicationContext的各种继承关系，以及servlet容器本身的一些配置问题，如果这部分工作交给spring框架去处理，那研发人员就可以减少很多麻烦。最终spring框架没有增加这个功能，而是新搞了一个项目，spring boot就诞生了。引用官方博客<a href="https://spring.io/blog/2013/08/06/spring-boot-simplifying-spring-for-everyone" target="_blank" rel="noopener">Simplifying Spring for Everyone</a>的一张图片：<br><img src="/images/2023033101%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8springboot/springboot.png" alt="spring boot overview"><br>可以看出springboot还会集成spring的所有子模块，达到开箱即用的目的，咱再也不用去配置繁琐的MVC、AOP这些配置了，这就是所谓的约定大于配置吧。</p><p>再说说spring boot的原理，从上面spring boot的发展可以了解到，框架不是独立存在的，需要强依赖spring，如果知道主流程的入口，很多地方就可以迎刃而解了。先看下spring boot入口注解SpringBootApplication：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@SpringBootConfiguration</span></span><br><span class="line"><span class="variable">@EnableAutoConfiguration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(excludeFilters = &#123; <span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public <span class="variable">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>好像EnableAutoConfiguration这个注解有点不一样，再看看内部定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@AutoConfigurationPackage</span></span><br><span class="line"><span class="variable">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line">public <span class="variable">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p>Import不就是spring的注解吗，再看看AutoConfigurationImportSelector：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">AutoConfigurationImportSelector</span> <span class="symbol">implements</span> <span class="symbol">DeferredImportSelector, <span class="symbol">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="symbol">ResourceLoaderAware, <span class="symbol">BeanFactoryAware</span>, <span class="symbol">EnvironmentAware</span>, <span class="symbol">Ordered</span></span> &#123;</span><br></pre></td></tr></table></figure><p>DeferredImportSelector是不是似曾相识的感觉，对就是通过spring的这个注解来集成其他模块的。我们再看下spring通过注解方式加载bean的一个流程：<br><img src="/images/2023033101%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8springboot/spring-configuration.png" alt="spring configuration"><br>我们看到ConfigurationClassParser会统一处理DeferredImportSelector的实现类，这也体现了spring的设计哲学<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview-philosophy" target="_blank" rel="noopener">Provide choice at every level</a>。</p><p>至此，spring boot的原理以及大概流程就清楚了，其他的功能就写几个demo应该就没撒问题了。如果是新项目那就赶紧换spring boot吧，真的太方便了，老项目就根据实际情况调整吧，总的来说spring boot还是沿用了spring最初的一些设计哲学，这里还是要强烈推荐下spring作者Rod Johnson写的这本书<a href="https://book.douban.com/subject/1483761/" target="_blank" rel="noopener">《Expert One-on-One J2EE Design and Development》</a>，介绍了spring诞生前的一些设计思想，虽然过去了10多年，但这些编程思想并不过时。</p>]]></content>
      
      
      <categories>
          
          <category> spring文集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring,springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper集群启动分析</title>
      <link href="/2016/12/10/7.1zookeeper%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/2016/12/10/7.1zookeeper%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这里从最简单的安装zookeeper的时候，看如何进行选举的，先把最简单的一种梳理好，后面可能涉及到复杂的场景就好整了。</p><h1 id="集群环境配置"><a href="#集群环境配置" class="headerlink" title="集群环境配置"></a>集群环境配置</h1><ul><li>下载最新的release包，把config目录的zoo_sample.cfg修改为zoo.cfg</li><li>修改配置文件，为了方便源码分析，参数可以循序渐进的加，这里整最基本的参数就OK，配置内容如下：<br><img src="/images/zookeeper/7.1-1.png" alt><br>dataDir就为zookeeper内部的数据库路径</li><li>在dataDir目录新增myid文件，并且里面的值与上面配置文件的server.x参数的数字要一致，如server.2在myid中的值就为2，这个参数很重要，就是server的id，后面选举的时候会用到</li><li>启动server，./zkServer.sh start，启动前面两台会有java.net.ConnectException: Connection refused: connect，为正常情况，因为配置文件里面配置了3个server，启动的时候会向这些server发送选举请求，没有启动，就连接不上了</li><li>查看集群状态，使用<a href="http://zookeeper.apache.org/doc/r3.4.9/zookeeperAdmin.html" target="_blank" rel="noopener">四字命令</a>stat查看server状态<br><img src="/images/zookeeper/7.1-2.png" alt><br>说明集群就成功了。<br>为了方便debug代码，我把server.4换成了本机的ip地址，各个节点的zoo.cfg也替换掉，在本机执行QuorumPeerMain的main函数即可，如下图：<br><img src="/images/zookeeper/7.1-3.png" alt></li></ul><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>直接参考main函数，由于启动的时候加了zoo.cfg配置文件，所有集群模式的函数runFromConfig，里面设置了QuorumPeer（参与者）一些基本参数，参考代码：</p><pre><code>public void runFromConfig(QuorumPeerConfig config) throws IOException {     。。。      ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();      LOG.debug(&quot;初始化NIOServerCnxnFactory配置&quot;);      cnxnFactory.configure(config.getClientPortAddress(),                            config.getMaxClientCnxns());      quorumPeer = new QuorumPeer();      quorumPeer.setClientPortAddress(config.getClientPortAddress());      //配置文件路径      quorumPeer.setTxnFactory(new FileTxnSnapLog(                  new File(config.getDataLogDir()),                  new File(config.getDataDir())));      //设置集群的server      LOG.debug(&quot;设置选举法人quorumPeers&quot;);      quorumPeer.setQuorumPeers(config.getServers());      //设置选举算法类型，默认值为3（FastLeaderElection）      LOG.debug(&quot;设置选举算法类型，默认值为3（FastLeaderElection）,参考QuorumPeer.createElectionAlgorithm&quot;);      quorumPeer.setElectionType(config.getElectionAlg());      quorumPeer.setMyid(config.getServerId());      quorumPeer.setTickTime(config.getTickTime());      quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());      quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());      quorumPeer.setInitLimit(config.getInitLimit());      quorumPeer.setSyncLimit(config.getSyncLimit());      //选票机制默认为QuorumMaj，N/2      LOG.debug(&quot;选票机制默认为QuorumMaj，N/2&quot;);      quorumPeer.setQuorumVerifier(config.getQuorumVerifier());      quorumPeer.setCnxnFactory(cnxnFactory);      quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));      //默认为提议者，LearnerType.PARTICIPANT      LOG.debug(&quot;初始化QuorumPeer，学习者类型默认为提案者，LearnerType.PARTICIPANT&quot;);      quorumPeer.setLearnerType(config.getPeerType());      quorumPeer.setSyncEnabled(config.getSyncEnabled());      quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());      quorumPeer.start();      quorumPeer.join();。。。}</code></pre><p>画了一个简单的时序图，参考如下：<br><img src="/images/zookeeper/7.1-4.png" alt><br>里面的涉及细节，下面再慢慢来分析。</p><h2 id="解析配置文件初始化"><a href="#解析配置文件初始化" class="headerlink" title="解析配置文件初始化"></a>解析配置文件初始化</h2><p>由QuorumPeerMain的initializeAndRun函数可以看到配置文件zoo.cfg被解析到QuorumPeerConfig对象了，里面集群的server保存到了Map里面，runFromConfig函数将解析出来的值分别设置到QuorumPeer对象。</p><h2 id="启动QuorumPeer线程前的准备工作"><a href="#启动QuorumPeer线程前的准备工作" class="headerlink" title="启动QuorumPeer线程前的准备工作"></a>启动QuorumPeer线程前的准备工作</h2><p>QuorumPeer的start方法分为3步：</p><ul><li>loadDataBase加载操作文件目录dataDir，刚启动的时候会新建两个重要的文件，acceptedEpoch（接受的选举轮次）、currentEpoch（当前选举轮次）</li><li>启动nio服务端NIOServerCnxnFactory.start</li><li>选择选举算法，zookeeper3.4以上版本内部默认只使用FastLeaderElection这个选举算法，创建FastLeaderElection之前，会先实例化QuorumCnxManager，把启动QuorumCnxManager.Listener线程，用于监听请求</li></ul><p>下面就对第三步进行详细分析。</p><p>通过上面分析可以知道，初始化FastLeaderElection类的时候，就已经把QuorumCnxManager.Listener线程启动了，这个线程就是各个server之间进行通信的入口，参考run方法，部分代码省略：</p><pre><code>@Override    public void run() {    。。。        while((!shutdown) &amp;&amp; (numRetries &lt; 3)){        try {                ss = new ServerSocket();                ss.setReuseAddress(true);                //是否监听所有ip，默认为false，配置文件可配置                if (self.getQuorumListenOnAllIPs()) {                    int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();                    addr = new InetSocketAddress(port);                } else {                    addr = self.quorumPeers.get(self.getId()).electionAddr;                }                LOG.info(&quot;My election bind port: &quot; + addr.toString());                setName(self.quorumPeers.get(self.getId()).electionAddr.toString());                ss.bind(addr);                while (!shutdown) {                    //刚启动时会阻塞在这里，收到发送的消息在这里就开始读取                    Socket client = ss.accept();                    setSockOpts(client);                    LOG.info(&quot;Received connection request &quot; + client.getRemoteSocketAddress());                    receiveConnection(client);                    numRetries = 0;                }            } catch (IOException e) {        }        。。。    }</code></pre><p>从上面的代码可以知道，启动的监听器线程如果没有建立连接，就会一直会阻塞在accept方法。实例化FastLeaderElection的时候，其内部会创建两个守护线程WorkerReceiver、WorkerSender并启动，这两个线程就是各个server之间选举投票发送接收信息的处理器，前期的准备工作就做好了。</p><h2 id="执行QuorumPeer线程"><a href="#执行QuorumPeer线程" class="headerlink" title="执行QuorumPeer线程"></a>执行QuorumPeer线程</h2><p>从run方法里面可以看到，这个线程会一直运行，直到选举成功，状态修改为非LOOKING状态。接下来选举的过程就交给FastLeaderElection了。参考lookForLeader方法，在开始的时候，会初始化一个逻辑时钟logicalclock，用于同一轮的选举，再通过sendNotifications方法，向发送消息队列写入3个配置好的server信息，如果是自己的serverid就不连接自己的服务器了，直接添加到收到信息队列里面，然后把自己的serverid发送给其他两台服务器。如下图所示，接收到的serverId比自己大的情况：<br><img src="/images/zookeeper/7.1-5.png" alt></p><p>从上面可以看出就是二阶段协议，最终FastLeaderElection就接收到选举通知并存到recvqueue，然后根据这些通知信息进行选举。totalOrderPredicate这个方法就是投票规则，如果同一轮选票，serverId越大或者zxid（事务id）越大，成leader的概率就越大，如（3,5）表示serverId为3,5表示zxid，同一轮选举，zxid越大就投给谁，如下图所示，最后的leader为（1,6）：<br><img src="/images/zookeeper/7.1-6.png" alt><br>每改变一次投票都会存档（保存到recvset这个集合），最后通过termPredicate方法判断选票节点大于半数就选择修改后的投票里面的server为Leader，如果当前的serverId与修改后的投票里面的serverId相等，那么把QuorumPeer的state修改为LEADING，否则为FOLLOWING。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring MVC处理Excel视图的三种方式</title>
      <link href="/2016/11/02/6.7spring%20MVC%E5%A4%84%E7%90%86Excel%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2016/11/02/6.7spring%20MVC%E5%A4%84%E7%90%86Excel%E8%A7%86%E5%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前段时间在一个项目里面发现，针对Excel的处理没有一个公用的视图，来个下载的需求就要自己去写一堆POI的东西，终于有一天给我也来了几个，还是按照以前的方式来写，写多了真心想吐，后面想想还是有必要整个解析Excel的视图了。花了一天时间，总结出来共有三种方式可以处理Excel视图。</p><a id="more"></a><!-- --- --><p>由于spring已经提供了excel的抽象视图，所以我们直接继承过来就可以了。由于POI对excel2007和2003处理方式有些不同，所以spring4.2以上版本提供了两个excel抽象视图AbstractXlsxView（2007）、AbstractXlsView（2003）。现在又想到曾经公司的报表系统了，下载一年的销售数据，有上百万的数据在一个excel里面，打开直接卡死，后面还得分批次查询去搞，针对这种情况，程序里面其实可以一次性搞定的，分页查询、切割结果集到多个列表、多线程处理等等，所以处理的结果集最后还是放到Map里面的，以防数据量大的时候分成多个列表下载。这里还是只分析3中视图如何处理的，关于性能方面的东西，在实际项目中还是要充分考虑，这里就不分析了。下面的代码都是以excel2003进行分析。</p><p>这三种解析方式都要用到具体的Excel实现类，代码如下：</p><pre><code>public class ExcelView extends AbstractXlsView {    @Override    protected void buildExcelDocument(Map&lt;String, Object&gt; model, Workbook workbook, HttpServletRequest request,            HttpServletResponse response) throws Exception {        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ new String((DateFormatUtils.format(new Date(), &quot;yyyyMMddHHmmss&quot;) + &quot;.xls&quot;).getBytes(), &quot;iso-8859-1&quot;));        //分割list        for (Entry&lt;String, Object&gt; e : model.entrySet()) {            HSSFSheet sheet = (HSSFSheet) workbook.createSheet(&quot;测试&quot;);            if (e.getValue() instanceof List) {                List&lt;?&gt; dataList = (List&lt;?&gt;) e.getValue();                HSSFRow rowHeader = sheet.createRow(0);                //添加header                rowHeader.createCell(0).setCellValue(&quot;id&quot;);                rowHeader.createCell(1).setCellValue(&quot;名字&quot;);                for (int start = 0; start &lt; dataList.size(); start++) {                    HSSFRow row = sheet.createRow(start + 1);                    String[] rowsText = dataList.get(start).toString().split(&quot;,&quot;);                    for (int col = 0; col &lt; rowsText.length; col++) {                        HSSFCell cell = row.createCell(col);                        cell.setCellValue(rowsText[col]);                    }                }            }        }    }}</code></pre><p>由于在AbstractXlsView里面，已经做了ContentType以及流的写入，所以我们直接把HSSFSheet里面的数据设置下就可以了。</p><h1 id="直接添加excel视图到ModelAndView"><a href="#直接添加excel视图到ModelAndView" class="headerlink" title="直接添加excel视图到ModelAndView"></a>直接添加excel视图到ModelAndView</h1><p>这种方式和其他方式差不多，只是把ExcelView作为参数传到ModelAndView，代码如下：</p><pre><code>@RequestMapping(&quot;/download&quot;)public ModelAndView test() {    ModelAndView mav = new ModelAndView();    ExcelView excelView = new ExcelView();    List&lt;Student&gt; list = new ArrayList&lt;&gt;();    Student student = new Student();    student.setId(1);    student.setName(&quot;hello&quot;);    list.add(student);    student = new Student();    student.setId(2);    student.setName(&quot;world&quot;);    list.add(student);    mav.addObject(&quot;list&quot;, list);    mav.setView(excelView);    return mav;}</code></pre><p>不用做其他配置，发送一个请求就可以得到excel文件了，结果如下：</p><p><img src="/images/spring/6-1.png" alt></p><h1 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h1><p>类似于解析jsp，只要给定相应规则把请求指定到配置的解析器就可以了，代码如下：</p><pre><code>public class ExcelViewResolver extends AbstractCachingViewResolver implements Ordered {    private ApplicationContext context;    private int order = Integer.MAX_VALUE;  // default: same as non-Ordered    public void setOrder(int order) {        this.order = order;    }    @Override    public int getOrder() {        return this.order;    }    @Override    public boolean isCache() {        return false;    }    /**     * 直接在容器中配置视图，单例获取bean，不用每次新建，待优化 TODO     */    @Override    protected View loadView(String viewName, Locale locale) throws Exception {        context = super.getApplicationContext();        if (context != null) {            return context.getBean(viewName, View.class);        }        return null;    }}</code></pre><p>配置文件：</p><pre><code>&lt;bean class=&quot;com.myspring.web.view.ExcelViewResolver&quot;&gt;    &lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;excelView&quot; class=&quot;com.myspring.web.view.ExcelView&quot;/&gt;</code></pre><p>这种方式需要指定视图的名字为excelView，controller代码如下：</p><pre><code>@RequestMapping(&quot;/download1&quot;)public ModelAndView excel1() {    //针对指定的视图解析    ModelAndView mv = new ModelAndView(&quot;excelView&quot;);    List&lt;Student&gt; list = new ArrayList&lt;&gt;();    Student student = new Student();    student.setId(1);    student.setName(&quot;你好&quot;);    list.add(student);    student = new Student();    student.setId(2);    student.setName(&quot;世界&quot;);    list.add(student);    mv.addObject(&quot;list&quot;, list);    return mv;}</code></pre><p>运行结果：</p><p><img src="/images/spring/6-2.png" alt></p><h1 id="自定义注解解析返回值"><a href="#自定义注解解析返回值" class="headerlink" title="自定义注解解析返回值"></a>自定义注解解析返回值</h1><p>spring解析json视图的时候只要@ResponseBody注解就可以了，也不用其他配置，非常方便。解析excel一样可以这样做。首先自定义一个注解：</p><pre><code>@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Excel {}</code></pre><p>实现一个自定义的返回值处理器：</p><pre><code>public class ExcelMethodProcessor implements HandlerMethodReturnValueHandler {    @Override    public boolean supportsReturnType(MethodParameter returnType) {        return (AnnotationUtils.findAnnotation(returnType.getContainingClass(), Excel.class) != null ||                returnType.getMethodAnnotation(Excel.class) != null);    }    @Override    public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer,            NativeWebRequest webRequest) throws Exception {        mavContainer.setRequestHandled(true);        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);        ExcelView view = new ExcelView();        if (returnValue instanceof Map) {            view.render( (Map)returnValue, request, response);        } else {            ModelMap model = new ModelMap();            model.addAttribute(&quot;returnValue&quot;, returnValue);            view.render(model, request, response);        }    }}</code></pre><p>配置文件里面需要把这个bean注入到容器：</p><pre><code>&lt;mvc:annotation-driven&gt;    &lt;mvc:return-value-handlers&gt;        &lt;bean class=&quot;com.myspring.web.view.ExcelMethodProcessor&quot;/&gt;    &lt;/mvc:return-value-handlers&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>配置完之后，我们就只需在Controller层加个注解就完事儿了，非常简洁，代码如下：</p><pre><code>@RequestMapping(&quot;/download2&quot;)@Excelpublic List&lt;Student&gt; excel2() {    List&lt;Student&gt; list = new ArrayList&lt;&gt;();    Student student = new Student();    student.setId(1);    student.setName(&quot;Tom&quot;);    list.add(student);    student = new Student();    student.setId(2);    student.setName(&quot;Jerry&quot;);    list.add(student);    return list;}</code></pre><p>运行结果：</p><p><img src="/images/spring/6-3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码分析之MVC简介</title>
      <link href="/2016/10/20/6.6spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMVC%E5%88%86%E6%9E%90/"/>
      <url>/2016/10/20/6.6spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMVC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>springMVC遵循OCP（Open-Closed Principle，开放封闭原则）而实现MVC，平时项目要做某部分特殊功能时，只要实现相应的接口就可以了，非常灵活也易于扩展，MVC模型在JEE平台中属于描述层，JEE将MVC细分了更多的模式，后面有时间了再分析JEE模式在spring中如何实现的，这里做个大概的介绍。spring MVC模型如下：</p><a id="more"></a><!-- --- --><p><img src="/images/spring/5-1.png" alt></p><p>spring通过DispatcherServlet（<a href="http://www.oracle.com/technetwork/java/frontcontroller-135648.html" target="_blank" rel="noopener">Front Controller</a>，前端控制器模式）将各个层分离，各司其职，模块之间更易于扩展。为什么要用Front Controller？这个控制器就主要绑定映射、视图解析、异常处理、请求调用等待，如果没有这层，经常会有一个功能的增删改查，每个控制层就要去写一次增删改查的判断，现在servlet3以上版本支持注解了解决了这个问题，但是每个方法里面还是有视图层耦合，前端控制器模式就很好的解决了这些问题。</p><p>参考<a href="http://zeng233.github.io/2016/09/04/6.1spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BIoc%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90/">《spring源码分析之Ioc容器分析》</a>，整个MVC相关的bean控制由XmlWebApplicationContext，一般项目里面对bean的配置有两种，参考下图：</p><p><img src="/images/spring/5-2.png" alt></p><p>这种配置是将web Ioc容器与应用的父级容器分离，这种方式如果没配置好，有时候会遇到一些问题，如事务失效、aop不起作用等等，大多数都是bean不在相应的IoC容器中造成的。</p><p><img src="/images/spring/5-3.png" alt></p><p>这种方式就是将web 中的bean和父级bean融合在一个容器中了。</p><h1 id="前端控制器DispatcherServlet各个组件"><a href="#前端控制器DispatcherServlet各个组件" class="headerlink" title="前端控制器DispatcherServlet各个组件"></a>前端控制器DispatcherServlet各个组件</h1><p>DispatcherServlet在前面说了，作为web应用的入口点，控制着整个请求流程，大概包含了如下组件：</p><p><img src="/images/spring/5-4.png" alt></p><p>DispatcherServlet初始化以及分发请求的大致流程如下：</p><p><img src="/images/spring/5-5.png" alt></p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>如上图所示，在DispatcherServlet初始化的时候，做了很多初始化工作，这就包含请求地址与应用层的Controller绑定了，HandlerMapping的类图如下：</p><p><img src="/images/spring/5-6.png" alt></p><p>可以看到具体的实现类实现了InitializingBean接口，在初始化的时候就要执行afterPropertiesSet，这个方法就是绑定映射了，以RequestMappingHandlerMapping为例，执行流程如下：</p><p><img src="/images/spring/5-7.png" alt></p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>这层主要将请求处理完（包含请求数据绑定）之后的结果返回给DispatcherServlet，再由视图解析器根据结果进行视图渲染。<br>在DispatcherServlet分发请求的时候会执行doDispatch方法：</p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    。。。    // Determine handler adapter for the current request.    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());    // Process last-modified header, if supported by the handler.    String method = request.getMethod();    boolean isGet = &quot;GET&quot;.equals(method);    if (isGet || &quot;HEAD&quot;.equals(method)) {        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());        if (logger.isDebugEnabled()) {            logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);        }        if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {            return;        }    }    //执行链执行拦截器HandlerInterceptor.preHandle    if (!mappedHandler.applyPreHandle(processedRequest, response)) {        return;    }    // Actually invoke the handler.    //这时HandlerExecutionChain的handler对象为url映射的HandlerMethod    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());    if (asyncManager.isConcurrentHandlingStarted()) {        return;    }    applyDefaultViewName(processedRequest, mv);    //请求执行完后拦截器再处理    mappedHandler.applyPostHandle(processedRequest, response, mv);    。。。}</code></pre><p>以RequestMappingHandlerAdapter为例，执行流程如下：</p><p><img src="/images/spring/5-8.png" alt></p><p>最后参数绑定就在DataBinder类执行了，如下所示：</p><pre><code>protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {    BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),            getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());    if (this.conversionService != null) {        result.initConversion(this.conversionService);    }    return result;}</code></pre><p>参数转换的时候也用的BeanWrapper来封装的，绑定完参数就执行方法了，因为容器启动的时候就把相关的url绑定到具体的方法了，所以这里利用反射直接调用方法执行了，参考InvocableHandlerMethod：</p><pre><code>public Object invokeForRequest(NativeWebRequest request, ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    //获取解析类处理后的方法参数    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        StringBuilder sb = new StringBuilder(&quot;Invoking [&quot;);        sb.append(getBeanType().getSimpleName()).append(&quot;.&quot;);        sb.append(getMethod().getName()).append(&quot;] method with arguments &quot;);        sb.append(Arrays.asList(args));        logger.trace(sb.toString());    }    //执行requestMapping绑定的方法    Object returnValue = doInvoke(args);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Method [&quot; + getMethod().getName() + &quot;] returned [&quot; + returnValue + &quot;]&quot;);    }    return returnValue;}</code></pre><p>然后在ServletInvocableHandlerMethod把返回的结果用returnValueHandler把视图以及Model的设置到ModelAndViewContainer。最后在RequestMappingHandlerAdapter生成ModelAndView对象：</p><pre><code>private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,        ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {    modelFactory.updateModel(webRequest, mavContainer);    if (mavContainer.isRequestHandled()) {        return null;    }    ModelMap model = mavContainer.getModel();    ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model);    if (!mavContainer.isViewReference()) {        mav.setView((View) mavContainer.getView());    }    if (model instanceof RedirectAttributes) {        Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);        RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);    }    return mav;}</code></pre><h2 id="Resolving-views"><a href="#Resolving-views" class="headerlink" title="Resolving views"></a>Resolving views</h2><p>视图解析有两个重要的接口ViewResolver（解析指定标示的视图）和View（把视图结果写到HttpServletResponse返回给客户端）。<br>又回到DispatcherServlet，把返回的ModelAndView交给processDispatchResult处理，里面的解析器在配置文件加载的时候就初始化好了，如果需要解析自定义的视图，只要实现ViewResolver即可。spring内部也提供了大量的视图解析器，如下图：</p><p><img src="/images/spring/5-9.png" alt></p><p>解析完文件就会生成相应的视图，spring内部的视图如下：</p><p><img src="/images/spring/5-10.png" alt></p><p>jsp解析器对应的视图就为InternalResourceView，渲染结果如下：</p><pre><code>protected void renderMergedOutputModel(        Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {    // Expose the model object as request attributes.    exposeModelAsRequestAttributes(model, request);    // Expose helpers as request attributes, if any.    exposeHelpers(request);    // Determine the path for the request dispatcher.    String dispatcherPath = prepareForRendering(request, response);    // Obtain a RequestDispatcher for the target resource (typically a JSP).    RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);    if (rd == null) {        throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +                &quot;]: Check that the corresponding file exists within your web application archive!&quot;);    }    // If already included or response already committed, perform include, else forward.    if (useInclude(request, response)) {        response.setContentType(getContentType());        if (logger.isDebugEnabled()) {            logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);        }        rd.include(request, response);    }    else {        // Note: The forwarded resource is supposed to determine the content type itself.        if (logger.isDebugEnabled()) {            logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);        }        rd.forward(request, response);    }}</code></pre><p>如果是ajax异步请求，在处理返回结果的时候就已经处理了，ModelAndViewContainer设置属性requestHandled为true，表示已经处理了，spring3以上支持很多注解，异步返回使用@ResponseBody注解，就使用RequestResponseBodyMethodProcessor处理返回结果。spring4.2以上默认使用jackson和gson解析json格式的返回类型，参考AnnotationDrivenBeanDefinitionParser：</p><pre><code>private Properties getDefaultMediaTypes() {        Properties props = new Properties();        if (romePresent) {            props.put(&quot;atom&quot;, MediaType.APPLICATION_ATOM_XML_VALUE);            props.put(&quot;rss&quot;, &quot;application/rss+xml&quot;);        }        if (jaxb2Present || jackson2XmlPresent) {            props.put(&quot;xml&quot;, MediaType.APPLICATION_XML_VALUE);        }        if (jackson2Present || gsonPresent) {            props.put(&quot;json&quot;, MediaType.APPLICATION_JSON_VALUE);        }        return props;    }</code></pre><p>springMVC的大致流程就分析完了，从以上分析可以看出，spring严格按照OCP、SRP（单一责任原则）实现，各个模块各司其职，降低了耦合度，扩展也很方便。有些涉及到具体细节没有详细分析，后面针对具体复杂点的业务再详细说明。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务失效常见问题分析</title>
      <link href="/2016/10/08/6.4spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2016/10/08/6.4spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在以前的项目开发中，经常会听到我这个方法的事务怎么没有起作用呢？虽然经过一番折腾把问题解决了，但是对于spring事务本质的一些东西感觉并没有搞明白。这里就以前项目中遇到的实际问题，再加上自己在一些java群里面看到的问题，对spring事务失效问题做个总结。</p><a id="more"></a><!-- --- --><p>以下分析都是基于bean已经在容器中了，有时候事务失效也会因为包没有被扫描到或者xml配置文件没有将bean注册到容器中，这个很少见就不单独说了，下面这些问题就是开发中可能比较常见的问题，这里列出来的也许不全，后期遇到了再补上。</p><h1 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h1><p>对于xml或者annotation集中式管理事务，常常会配置在pointcut标签或者注解配置一个表达式，save或者update开头的方法加事务，如果项目是按照模块化分包的，就容易出现覆盖不全的情况，从而造成事务失效。</p><h1 id="不在一个容器管理范围"><a href="#不在一个容器管理范围" class="headerlink" title="不在一个容器管理范围"></a>不在一个容器管理范围</h1><p>这个问题经常发生在于springMVC项目中，在<a href="http://zeng233.github.io/2016/10/20/6.6spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMVC%E5%88%86%E6%9E%90/">spring源码分析之MVC简介</a>章节分析了，springMVC的web容器是root容器的一个子容器，有的项目会在web.xml将两个容器分别配置，而web容器里面使用<a href="context:component-scan">context:component-scan</a>标签扫描包将service层的类也给扫到了，就会造成web子容器就有service类了，但是事务的配置又在root容器中，就会造成拿到的bean是web子容器中的bean，并不是一个代理bean，函数调用的时候压根儿就不在事务的拦截器链了，这个问题我相信很多springMVC的项目都会遇到。</p><h1 id="同一个方法嵌套调用"><a href="#同一个方法嵌套调用" class="headerlink" title="同一个方法嵌套调用"></a>同一个方法嵌套调用</h1><p>这个问题自己在一个项目开发中也遇到过，就是将事务操作失败的日记记录到日志表中，当时就想当然的直接在service方法中增加一个记录日志的方法，事务的传播属性设置为REQUIRES_NEW，结果自测的时候，发现日志表中并没有记录错误日志。如下图所示：<br><img src="/images/spring/18.1-1.png" alt></p><p>从图中可以看出，如果是目标函数内部的方法调用，是不会走事务拦截过程的，因为事务只是spring aop的一个advice，所以要实现事务的功能，目标函数类必须是一个代理对象，参考<a href="http://zeng233.github.io/2016/10/07/6.5spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAOP%E5%88%86%E6%9E%90/">spring源码分析之AOP分析</a>。如果要在同一个类中调用方法使事务生效，就要使用&lt;aop:config expose-proxy=”true”&gt;标签，并且将expose-proxy设置为true，内部在执行目标函数的时候，就会把当前的代理类放到AopContext，内部调用的时候就不能直接写方法调用了，要使用AopContext.currentProxy()获取当前的代理类再执行要使用的方法。spring官方文档也说明了这个<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop-understanding-aop-proxies" target="_blank" rel="noopener">问题</a>。</p><p>综上所述，不管以后遇到什么事务失效的问题，首先就应该判断目标函数所在对象是不是一个代理对象，spring有个AopUtils类，不管项目使用jdk proxy还是cglib，或者两种一起用的，使用这个工具类就可以判断是不是代理对象，经过这样的判断可以排除大多数问题。网上还有其他什么自己配置了创建代理对象类，造成二次代理失效的，如果项目中有aop配置，事务创建代理对象的工厂类与aop使用的是同一个类AspectJAwareAdvisorAutoProxyCreator，如果没有特殊需求，还是使用<a href="aop:config">aop:config</a>标签，不然自己配置创建代理对象类，很容易造成拦截器链的丢失，从而造成事务失效。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码分析之AOP分析</title>
      <link href="/2016/10/07/6.5spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAOP%E5%88%86%E6%9E%90/"/>
      <url>/2016/10/07/6.5spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BAOP%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h1><p>什么是AOP？这可能是学习AOP时，最想知道的问题，在研究spring aop这块查阅了大量的资料，即使AOP联盟当初指定的规范也没有解释这个概念，如同OOP一样，AOP只是一种编程思想了，水平有限我只能这样解释了。OOP代码中的体现就是类了，那AOP呢？其实也是类（也可以理解为模块化），所谓的特殊的横切组织，参考下图：</p><a id="more"></a><!-- --- --><p><img src="/images/spring/4-1.png" alt></p><p>一般项目里面的函数会包含业务性处理与非业务性处理两种，随着业务的发展里面可能会包含很多非业务的处理，这些非主业务的处理有可能在其他地方继续调用，这样代码的耦合性就非常高了。灰色的切面就是AOP的体现了，这些非业务的处理从代码中解耦出来就优雅多了。如果要实现自己的AOP组件要包含拦截器框架、字节码解析、织入组件（如动态代理）、配置组件，摘自<a href="http://aopalliance.sourceforge.net/motivations.html" target="_blank" rel="noopener">AOP联盟</a></p><blockquote><p>All these projects have their onw goals and speficities. However, several common basic components are still usefull (and sometimes required) to build a full AO system. For instance, a component that is able to add metadata on the base components, an interception framework, a component that is able to perform code translation in order to advice the classes, a weaver component, a configuration component, and so on.</p></blockquote><h1 id="spring-AOP简介"><a href="#spring-AOP简介" class="headerlink" title="spring AOP简介"></a>spring AOP简介</h1><p>如上面所述，spring实现AOP就包含了其中一些组件，如下图所示：</p><p><img src="/images/spring/4-2.png" alt></p><p>Spring AOP提供了几个重要概念性的东西，参考<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop-introduction-defn" target="_blank" rel="noopener">文档</a>，其中Joinpoint与Advice是aop联盟提供的aop接口，Advice就广义的理解为拦截器，Joinpoint就是方法的执行（spring采用动态代理执行），Pointcut匹配的执行方法集合。<br>spring内部AOP实现包含了动态代理（JDK proxy、cglib proxy）与静态代理（AspectJ实现参考<a href="http://www.eclipse.org/aspectj/doc/next/devguide/ltw.html" target="_blank" rel="noopener">这里</a>，在编译期间织入），<br>spring AOP只指针对<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop-introduction-spring-defn" target="_blank" rel="noopener">方法级别</a>，如果想粒度更细（如改变属性或者构造函数之类的）就要AspectJ了，但是spring解析Pointcut方法匹配还是用的AspectJ相关的包。</p><h1 id="创建代理bean"><a href="#创建代理bean" class="headerlink" title="创建代理bean"></a>创建代理bean</h1><p>下面以JDK动态代理实现AOP为例进行分析，配置文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;bean id=&quot;foo&quot; class=&quot;mytest.aop.FooImpl&quot;/&gt;    &lt;bean id=&quot;aroundBean&quot; class=&quot;mytest.aop.config.AroundBean&quot;/&gt;    &lt;bean id=&quot;myAdvice&quot; class=&quot;mytest.aop.config.MyAdvice&quot;/&gt;    &lt;bean id=&quot;myAspect&quot; class=&quot;mytest.aop.config.MyAspect&quot;/&gt;    &lt;aop:config&gt;        &lt;aop:pointcut expression=&quot;execution(* mytest.aop.config.*.*(..))&quot; id=&quot;pc&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;pc&quot;/&gt;        &lt;aop:aspect ref=&quot;myAspect&quot;&gt;            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;pc&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><p>参考《spring源码分析之基于注解配置的bean初始化分析》，跟分析<a href="context:component-scan/">context:component-scan/</a>标签差不多，使用<a href="aop:config">aop:config</a>就由AopNamespaceHandler解析命名空间，然后ConfigBeanDefinitionParser解析标签，最后把AspectJAwareAdvisorAutoProxyCreator注册到容器中：</p><p><img src="/images/spring/4-3.png" alt></p><p>从这个图中就可以看出，AspectJAwareAdvisorAutoProxyCreator是BeanPostProcessor的一个子类，这个类就是执行创建代理bean的入口。整个创建流程参考下图：</p><p><img src="/images/spring/4-4.png" alt></p><p>初始化bean之前AspectJAwareAdvisorAutoProxyCreator将排除一些类不会生成代理类，如Advisor、Advice、Aspect以及Pointcut不匹配的类，参考AbstractAutowireCapableBeanFactory：</p><pre><code>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {    //执行initializeBean，bean是否有其他操作（如代理对象）    if (System.getSecurityManager() != null) {        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {            @Override            public Object run() {                invokeAwareMethods(beanName, bean);                return null;            }        }, getAccessControlContext());    }    else {        invokeAwareMethods(beanName, bean);    }    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) {//排除Advice、Advise、Aspect切面相关的类，并创建拦截器链        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }    try {        invokeInitMethods(beanName, wrappedBean, mbd);    }    catch (Throwable ex) {        throw new BeanCreationException(                (mbd != null ? mbd.getResourceDescription() : null),                beanName, &quot;Invocation of init method failed&quot;, ex);    }    if (mbd == null || !mbd.isSynthetic()) {        //AspectJAwareAdvisorAutoProxyCreator执行创建代理对象        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><p>参考applyBeanPostProcessorsAfterInitialization方法，创建代理bean就有AspectJAwareAdvisorAutoProxyCreator的父类AbstractAdvisorAutoProxyCreator执行：</p><pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {    if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) {        return bean;    }    //postProcessBeforeInstantiation方法已经将排除的bean放置到advisedBeans    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {        return bean;    }    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {        this.advisedBeans.put(cacheKey, Boolean.FALSE);        return bean;    }    //获取Alliance中实现的Interceptors    //一般bean如果不包含在PointCut表达式中，返回为null    // Create proxy if we have advice.    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //将拦截器链传递给ProxyFactory        Object proxy = createProxy(                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }    this.advisedBeans.put(cacheKey, Boolean.FALSE);    return bean;}</code></pre><p>前面的配置文件没有特殊的配置，spring内部默认使用JDK动态代理，参考DefaultAopProxyFactory：</p><pre><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {    mylog.debug(&quot;创建JdkDynamicAopProxy还是ObjenesisCglibAopProxy&quot;);    //检查是不是接口，或者是不是强制设置ProxyTargetClass为true，是就使用Cglib代理    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {        Class&lt;?&gt; targetClass = config.getTargetClass();        if (targetClass == null) {            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +                    &quot;Either an interface or a target is required for proxy creation.&quot;);        }        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {            return new JdkDynamicAopProxy(config);        }        return new ObjenesisCglibAopProxy(config);    }    else {        return new JdkDynamicAopProxy(config);    }}</code></pre><p>然后JdkDynamicAopProxy通过getProxy就获取到代理对象了。再些一个测试类，使用上面的配置文件：</p><pre><code>@Testpublic void testProxy() {    ITestBean aroundBean = (ITestBean) context.getBean(&quot;aroundBean&quot;);    IFoo foo = (IFoo)context.getBean(&quot;foo&quot;);    System.out.println(&quot;aroundBean：&quot; + AopUtils.isAopProxy(aroundBean));    System.out.println(&quot;foo：&quot; + AopUtils.isAopProxy(foo));}</code></pre><p>输入结果为：</p><pre><code>aroundBean：truefoo：false</code></pre><p>aroundBean在拦截表达式内，所以是代理对象，foo不在该范围内就不是代理对象。</p><h1 id="执行代理bean"><a href="#执行代理bean" class="headerlink" title="执行代理bean"></a>执行代理bean</h1><p>由于跟bean相关的拦截器初始化时就已经配置好了，JdkDynamicAopProxy实现了InvocationHandler，所以执行bean的方法时就直接调用invoke方法，执行流程如下：</p><p><img src="/images/spring/4-5.png" alt></p><p>参考ReflectiveMethodInvocation（Joinpoint的一个实现类）执行拦截器链以及目标函数：</p><pre><code>public Object proceed() throws Throwable {    //    We start with an index of -1 and increment early.    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {        return invokeJoinpoint();    }    Object interceptorOrInterceptionAdvice =            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {        // Evaluate dynamic method matcher here: static part will already have        // been evaluated and found to match.        InterceptorAndDynamicMethodMatcher dm =                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {            return dm.interceptor.invoke(this);        }        else {            // Dynamic matching failed.            // Skip this interceptor and invoke the next in the chain.            return proceed();        }    }    else {        // It&apos;s an interceptor, so we just invoke it: The pointcut will have        // been evaluated statically before this object was constructed.        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);    }}</code></pre><p>执行测试代码</p><pre><code>@Testpublic void testAround() {    //如果是JDK代理只能声明接口，获取到的实例是JDK产生的代理bean    ITestBean aroundBean = (ITestBean) context.getBean(&quot;aroundBean&quot;);    aroundBean.print();}</code></pre><p>最后打印输出：</p><pre><code>MyAspect: around beforeAroundBean&apos;s printMyAspect: around after</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码分析之基于注解配置的bean初始化分析</title>
      <link href="/2016/09/06/6.3spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90/"/>
      <url>/2016/09/06/6.3spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>实际开发项目中，配置bean一般都是使用注解，还是单独拿出来详细分析下，也把前面没有说的注入方式，全部集中到这里分析了。</p><h1 id="使用注解初始化bean的种类"><a href="#使用注解初始化bean的种类" class="headerlink" title="使用注解初始化bean的种类"></a>使用注解初始化bean的种类</h1><p>注解初始化bean大致有三种配置：</p><h2 id="AnnotationConfigApplicationContext启动初始化"><a href="#AnnotationConfigApplicationContext启动初始化" class="headerlink" title="AnnotationConfigApplicationContext启动初始化"></a>AnnotationConfigApplicationContext启动初始化</h2><p>使用AnnotationConfigApplicationContext或者AnnotationConfigWebApplicationContext启动的时候注册带Configuration注解的类，如下所示：</p><a id="more"></a><!-- --- --><pre><code> @Configuration public class AppConfig {     @Bean     public MyBean myBean() {         // instantiate, configure and return bean ...     } }AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.register(AppConfig.class); ctx.refresh(); MyBean myBean = ctx.getBean(MyBean.class);</code></pre><h2 id="使用-lt-context-annotation-config-gt-标签"><a href="#使用-lt-context-annotation-config-gt-标签" class="headerlink" title="使用&lt;\context:annotation-config/&gt; 标签"></a>使用&lt;\context:annotation-config/&gt; 标签</h2><p>在配置文件中声明：</p><pre><code>&lt;beans&gt;   &lt;context:annotation-config/&gt;   &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;&lt;/beans&gt;</code></pre><h2 id="使用-lt-context-component-scan-gt-标签"><a href="#使用-lt-context-component-scan-gt-标签" class="headerlink" title="使用&lt;\context:component-scan/&gt;标签"></a>使用&lt;\context:component-scan/&gt;标签</h2><pre><code>@Configuration public class AppConfig {     @Bean     public MyBean myBean() {         // instantiate, configure and return bean ...     } }</code></pre><p>这3种方式都是将bean集中到一个配置对象，现在比较流行的一种就是第三种方式，使用<a href="context:component-scan/">context:component-scan/</a>，现在就是这个标签为例，深入分析spring如何构造内置对象，以及把这些包路径下的bean注册到容器中的。</p><h1 id="解析标签"><a href="#解析标签" class="headerlink" title="解析标签"></a>解析标签</h1><p>参考《spring源码分析之基于xml配置文件的bean初始化分析》，在XmlBeanDefinitionReader创建XmlReaderContext对象的时候，就把默认路径META-INF/spring.handlers赋值给DefaultNamespaceHandlerResolver。DefaultBeanDefinitionDocumentReader在解析xml有两种类型标签，一种是符合<bean>schema规范的标签，另外一种就是非bean标签，参考DefaultBeanDefinitionDocumentReader：</bean></p><pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {    if (delegate.isDefaultNamespace(root)) {        NodeList nl = root.getChildNodes();        for (int i = 0; i &lt; nl.getLength(); i++) {            Node node = nl.item(i);            if (node instanceof Element) {                Element ele = (Element) node;                //判断是否符合bean标签约束                if (delegate.isDefaultNamespace(ele)) {                    parseDefaultElement(ele, delegate);                }                else {                    delegate.parseCustomElement(ele);                }            }        }    }    else {        delegate.parseCustomElement(root);    }}</code></pre><p>DefaultNamespaceHandlerResolver就根据xml命名空间获取到对应的NamespaceHandler，然后初始化并扫描包，把带注解的bean注册到BeanFactory，参考BeanDefinitionParserDelegate：</p><pre><code>public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {    String namespaceUri = getNamespaceURI(ele);    NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);    if (handler == null) {        error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);        return null;    }    return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));}</code></pre><p><a href="context:component-scan/">context:component-scan/</a>属于”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a> 命名空间，在spring.handlers文件中对应的是org.springframework.context.config.ContextNamespaceHandler：</p><pre><code>@Overridepublic void init() {    registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());    registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());    registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());    registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());    registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());    registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());    registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());    registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());}</code></pre><p>这下就简单了，component-scan标签对应的是ComponentScanBeanDefinitionParser解析器，查看parse方法：</p><pre><code>@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) {    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);    basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);    // Actually scan for bean definitions and register them.    //初始化时，默认的注解过滤器包含Component以及JEE标准的两个注解（ManagedBean、Named）    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);    return null;}</code></pre><p>有时候业务扩展了，里面的bean也随之增多，但是有可能最开始配置的扫描是整个项目，或者各个模块都配置了扫描包的标签，那会不会有影响呢？如果是全局扫描启动肯定有影响，spring内部是把&lt;context:component-scan base-package=”…”/&gt;base-packeage配置路径下的所有.class文件扫描，然后把这些路径缓存起来，再用初始化配置的注解filter过滤需要的bean，刚才分析了，如果没有特别的属性声明，默认就扫描Component注解（Controller、Service、Repository是Component的子类带这些注解的都会扫描），参考ClassPathScanningCandidateComponentProvider代码：</p><pre><code>public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) {。。。MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);                        if (isCandidateComponent(metadataReader)) {                            //创建AnnotatedBeanDefinition类型的bean                            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);                            sbd.setResource(resource);                            sbd.setSource(resource);                            if (isCandidateComponent(sbd)) {                                if (debugEnabled) {                                    logger.debug(&quot;Identified candidate component class: &quot; + resource);                                }                                candidates.add(sbd);。。。}</code></pre><p>在ClassPathScanningCandidateComponentProvider内部可以看到有个CachingMetadataReaderFactory，这个类在获取元素读取器的时候，是根据类路径去读取的，但是缓存了类路径到LinkedHashMap，所以如果有多个类路径重复了，后面重复的路径读取的是缓存中的MetadataReader，所以&lt;context:component-scan base-package=”…”/&gt;配置了相同的路径，效率不会有影响。最后生成ScannedGenericBeanDefinition，并注册到DefaultListableBeanFactory，参考ComponentScanBeanDefinitionParser：</p><pre><code>protected void registerComponents(        XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) {    Object source = readerContext.extractSource(element);    CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source);    for (BeanDefinitionHolder beanDefHolder : beanDefinitions) {        compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder));    }    // Register annotation config processors, if necessary.    boolean annotationConfig = true;    if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {        annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));    }    if (annotationConfig) {        //注册BeanPostProcessor，实例化bean依赖会用到        Set&lt;BeanDefinitionHolder&gt; processorDefinitions =                AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);        for (BeanDefinitionHolder processorDefinition : processorDefinitions) {            compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition));        }    }    readerContext.fireComponentRegistered(compositeDef);}</code></pre><p>AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source)这段代码就是把配置bean相关的注解注册到DefaultListableBeanFactory。注解与xml有点区别就是在注入的时候，使用的是BeanPostProcessor实现类通过反射注入。就拿CommonAnnotationBeanPostProcessor来分析，会处理jee api中的注解，如Resource、WebServiceRef、EJB。这些BeanPostProcessor只是生成了BeanDefinition并没有实例化，spring内部针对这些内置对象，在AbstractApplicationContext会执行registerBeanPostProcessors方法，将这些BeanPostProcessor实例化，这样Ioc容器内部就有各种用于bean处理的BeanPostProcessor了，在bean注入前后这些BeanPostProcessor都会对bean进行相关处理，BeanPostProcessor相关类图：</p><p><img src="/images/spring/3-1.png" alt></p><p>下面就直接分析注入了，由于CommonAnnotationBeanPostProcessor属于InstantiationAwareBeanPostProcessor的子类，所以初始化时就会被执行，AbstractAutowireCapableBeanFactory形成bean的方法中，就会执行注解方式的注入了，参考代码：</p><pre><code>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {。。。if (hasInstAwareBpps || needsDepCheck) {        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);        if (hasInstAwareBpps) {            //解析bean内部的注解            for (BeanPostProcessor bp : getBeanPostProcessors()) {                if (bp instanceof InstantiationAwareBeanPostProcessor) {                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);                    if (pvs == null) {                        return;                    }                }            }        }        if (needsDepCheck) {            checkDependencies(beanName, mbd, filteredPds, pvs);        }    }}</code></pre><p>在CommonAnnotationBeanPostProcessor的postProcessPropertyValues方法中就对bean就行注入了：</p><pre><code>@Overridepublic PropertyValues postProcessPropertyValues(        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);    try {        //处理bean内部是使用JSR注解的注入        metadata.inject(bean, beanName, pvs);    }    catch (Throwable ex) {        throw new BeanCreationException(beanName, &quot;Injection of resource dependencies failed&quot;, ex);    }    return pvs;}</code></pre><p>由于在初始化CommonAnnotationBeanPostProcessor的时候，只针对JEE API中的注解，所以生成的InjectionMetadata也只能包含这些注入元素了，参考InjectionMetadata的内部类InjectedElement通过属性注入，当然也支持方法注入，这里贴部分代码：</p><pre><code>protected void inject(Object target, String requestingBeanName, PropertyValues pvs) throws Throwable {        if (this.isField) {            Field field = (Field) this.member;            ReflectionUtils.makeAccessible(field);            //属性注入            field.set(target, getResourceToInject(target, requestingBeanName));        }        else {            if (checkPropertySkipping(pvs)) {                return;            }            try {                Method method = (Method) this.member;                ReflectionUtils.makeAccessible(method);                method.invoke(target, getResourceToInject(target, requestingBeanName));            }            catch (InvocationTargetException ex) {                throw ex.getTargetException();            }        }    }</code></pre><p>至此一个完整的bean就初始化完了。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码分析之基于xml配置文件的bean初始化分析</title>
      <link href="/2016/09/05/6.2spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90/"/>
      <url>/2016/09/05/6.2spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>spring初始化bean有xml与注解两种方式，虽然注解可以减少很多xml配置，但还是要在xml配置文件里面配置好标签之后才能生效，里面涉及到很多对xml命名空间的解析，对后面模块的分析也有帮助，所以先从xml解析初始化分析走，注解方式的注入就分析个大概了。随便吐槽下，分析开源框架最忌讳的就是陷入到分析解析xml去了，现在流行的框架差不多都会涉及到解析xml，每研究一个开源框架，分析xml都会花很多时间，其实不想写出来，因为没有技术含量，但是有时候跟同事交流又会问道怎么解析xml的，真的好蛋疼。由于spring有很多自定义标签而初始化了很多内嵌对象，所以还是写下初始化流程吧。</p><a id="more"></a><!-- --- --><p>这里先声明下，下面的分析只针对单个bean的初始化，并没有涉及到其他复杂场景的bean初始化，配置文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;         default-autowire=&quot;default&quot;&gt;    &lt;bean id=&quot;simple&quot; class=&quot;mytest.bean.simpleBean.SimpleBean&quot;/&gt;&lt;/beans&gt;</code></pre><p>就如此简单。</p><h1 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h1><p>从最简单的初始化一个bean进行分析，以ClassPathXmlApplicationContext为例，由于该类继承了AbstractApplicationContext，所以初始化的时候都是从refresh方法开始的。前面分析了，容器里面最核心的一个类是DefaultListableBeanFactory，在初始化解析器之前就要先创建该类。解析xml为BeanDefinition在obtainFreshBeanFactory完成，下面就详细分析改方法。</p><h2 id="初始化xml解析器"><a href="#初始化xml解析器" class="headerlink" title="初始化xml解析器"></a>初始化xml解析器</h2><p>参考前面章节的加载bean的入口在AbstractRefreshableApplicationContext的loadBeanDefinitions方法，由于XmlWebApplicationContext与一般的应用加载bean的配置文件有些不一样，所以loadBeanDefinitions是单独由实现的，其实内部还是由XmlBeanDefinitionReader完成bean的解析。ClassPathXmlApplicationContext、FileSystemXmlApplicationContext都由AbstractXmlApplicationContext的loadBeanDefinitions实现了初始化xml解析器操作。参考代码：</p><pre><code>@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {    // Create a new XmlBeanDefinitionReader for the given BeanFactory.    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);    // Configure the bean definition reader with this context&apos;s    // resource loading environment.    beanDefinitionReader.setEnvironment(this.getEnvironment());    beanDefinitionReader.setResourceLoader(this);    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));    // Allow a subclass to provide custom initialization of the reader,    // then proceed with actually loading the bean definitions.    initBeanDefinitionReader(beanDefinitionReader);    loadBeanDefinitions(beanDefinitionReader);}</code></pre><p>在实例化ResourceEntityResolver解析器时，在父类DelegatingEntityResolver初始化了BeansDtdResolver、PluggableSchemaResolver，这两种解析器分别解析dtd与schema两种方式的xml。</p><h2 id="解析配置文件为Document对象"><a href="#解析配置文件为Document对象" class="headerlink" title="解析配置文件为Document对象"></a>解析配置文件为Document对象</h2><p>实例化XmlBeanDefinitionReader的时候，内部的DefaultDocumentLoader就创建好了，此类完成创建Document对象。参考loadDocument方法：</p><pre><code>@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver,        ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);    if (logger.isDebugEnabled()) {        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);    }    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);    return builder.parse(inputSource);}</code></pre><p>由于实例化的时候已经设置了解析器为ResourceEntityResolver，所以直接看resolveEntity方法，有父类DelegatingEntityResolver去执行解析：</p><pre><code>@Overridepublic InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {    if (systemId != null) {        if (systemId.endsWith(DTD_SUFFIX)) {            return this.dtdResolver.resolveEntity(publicId, systemId);        }        else if (systemId.endsWith(XSD_SUFFIX)) {            return this.schemaResolver.resolveEntity(publicId, systemId);        }    }    return null;}</code></pre><p>由于spring都是使用的schema方式的定义的xml，所有使用PluggableSchemaResolver去解析xml，从这个类中就可以看到spring定义的xml标签约束了，在没个模块下面有个spring.schema文件，也就是以后的标签必须按照定义的schema规范来写标签。</p><h2 id="解析DOM节点"><a href="#解析DOM节点" class="headerlink" title="解析DOM节点"></a>解析DOM节点</h2><p>上面分析了已经创建好Docment对象了，接下来就解析DOM节点了。spring有一般的标签（如<bean>），还有种命名空间类型的标签（如：<a href="context:component-scan">context:component-scan</a>），第一种按照正常的流程解析就完了，而第二种就是需要初始化一些内部对象会用到了。参考把初始化后的Document对象传到XmlBeanDefinitionReader的registerBeanDefinitions方法：</bean></p><pre><code>public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    int countBefore = getRegistry().getBeanDefinitionCount();    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    return getRegistry().getBeanDefinitionCount() - countBefore;}</code></pre><p>需要注解的就是createReaderContext创建XmlReaderContext的时候，就有getNamespaceHandlerResolver方法把spring.handlers文件里面的内置对象加载进来了，用于解析命名空间类型的标签。DefaultBeanDefinitionDocumentReader将xml解析最后生成BeanDefinitionHolder，参考方法processBeanDefinition:</p><pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    if (bdHolder != null) {        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try {            // Register the final decorated instance.            //注册bean到容器（DefaultListableBeanFactory）            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());        }        catch (BeanDefinitionStoreException ex) {            getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; +                    bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex);        }        //触发注册监听器        // Send registration event.        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    }}</code></pre><p>这里比较重要的一个对象就是BeanDefinitionHolder的内部对象BeanDefinition，它保存了bean的所有信息，包括各种依赖关系，随便画了一个简单的类图：</p><p><img src="/images/spring/2-1.png" alt></p><p>至此解析XML就完成了。这里虽然没有介绍解析命名空间，但是后面分析注解的时候会顺带分析了，分析完自己也画了个时序图，包含了对命名空间类型节点的解析流程：</p><p><img src="/images/spring/2-2.png" alt></p><h2 id="实例化bean"><a href="#实例化bean" class="headerlink" title="实例化bean"></a>实例化bean</h2><p>由上面的分析就只之，解析xml保存到DefaultListableBeanFactory中的只是BeanDefinition，并没有实例化。上面都初始化都发生在AbstractApplicationContext的obtainFreshBeanFactory方法，在refresh方法中可以看到，有个finishBeanFactoryInitialization，只要是singleton的bean，这里就是实例化的入口了，最终会走到DefaultListableBeanFactory.preInstantiateSingletons()，遍历解析xml时保存的beanDefinitionNames，并调用getBean方法，参考AbstractBeanFactory的方法：</p><pre><code>protected &lt;T&gt; T doGetBean(        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)        throws BeansException {    ......            if (mbd.isSingleton()) {                sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {                    @Override                    public Object getObject() throws BeansException {                        try {                            //开始创建bean，由AbstractAutowireCapableBeanFactory实现                            return createBean(beanName, mbd, args);                        }                        catch (BeansException ex) {                            // Explicitly remove instance from singleton cache: It might have been put there                            // eagerly by the creation process, to allow for circular reference resolution.                            // Also remove any beans that received a temporary reference to the bean.                            destroySingleton(beanName);                            throw ex;                        }                    }                });                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            }    ......    return (T) bean;}</code></pre><p>注意获取bean的时候有个createBean方法，参考《spring源码分析之Ioc容器分析》，AbstractBeanFactory的子类就是AbstractAutowireCapableBeanFactory，所以这个类就是创建bean入口。由于不涉及到代理bean的创建，所以直接参考doCreateBean方法：</p><pre><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {    // Instantiate the bean.    BeanWrapper instanceWrapper = null;    if (mbd.isSingleton()) {        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);    }    if (instanceWrapper == null) {//实例化bean        instanceWrapper = createBeanInstance(beanName, mbd, args);    }    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);    Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);}</code></pre><p>将实例化后的bean设置到BeanWrapper （转换属性类型）</p><pre><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {    try {        Object beanInstance;        final BeanFactory parent = this;        if (System.getSecurityManager() != null) {            beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {                @Override                public Object run() {                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);                }            }, getAccessControlContext());        }        else {            //bean必须有空构造函数            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);        }        BeanWrapper bw = new BeanWrapperImpl(beanInstance);        initBeanWrapper(bw);        return bw;    }    catch (Throwable ex) {        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);    }}</code></pre><p>需要注意的是实例化的bean必须有空的构造函数，参考SimpleInstantiationStrategy类：</p><pre><code>@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {    // Don&apos;t override the class with CGLIB if no overrides.    if (bd.getMethodOverrides().isEmpty()) {        Constructor&lt;?&gt; constructorToUse;        synchronized (bd.constructorArgumentLock) {            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;            if (constructorToUse == null) {                final Class&lt;?&gt; clazz = bd.getBeanClass();                if (clazz.isInterface()) {                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);                }                try {                    if (System.getSecurityManager() != null) {                        constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {                            @Override                            public Constructor&lt;?&gt; run() throws Exception {                                return clazz.getDeclaredConstructor((Class[]) null);                            }                        });                    }                    else {                        //必须有空构造函数，不然反射就抛异常                        constructorToUse =    clazz.getDeclaredConstructor((Class[]) null);                    }                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;                }                catch (Exception ex) {                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);                }            }        }        return BeanUtils.instantiateClass(constructorToUse);    }    else {        // Must generate CGLIB subclass.        return instantiateWithMethodInjection(bd, beanName, owner);    }}</code></pre><p>然后通过反射实例化的bean添加到BeanWrapperImpl，看配置文件是否注册了转换器，最终BeanWrapperImpl通过getWrappedInstance就获取到实例化后的bean了。实例化bean也画了一个时序图，便于以后复习：</p><p><img src="/images/spring/2-3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码分析之IoC容器分析</title>
      <link href="/2016/09/04/6.1spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BIoc%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90/"/>
      <url>/2016/09/04/6.1spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BIoc%E5%AE%B9%E5%99%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时候去面试总会碰到问IoC原理的，但是很少看到问IoC分为哪几类，IoC与DI有什么区别，其实比较反感这种概念性的问题。04年的时候MartinFowler已经把这些东西解释了一遍，感兴趣的就到<a href="http://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">这里</a>，在这篇博客的参考文献发现80年代国外的叫兽就在论文里面提到了这些东西了，只是MartinFowler归纳总结出了个概念。既然写出来了，还是说说自己的理解。IoC翻译为控制反转，就是对bean的控制反转了，电影中有剧情反转、体育比赛有比赛反转等等，说得广泛点这些都可以看做是IoC，而java的实现就是跟bean相关的事情都不用自己去做了，都交给spring管理（有点像软件中的外包吧）。从下图也可以看出这几者的关系了：</p><a id="more"></a><!-- --- --><p><img src="/images/spring/1-1.png" alt><br>此图出自spring的作者Rod Johnson的《Expert One-on-One J2EE Development without EJB》一书。在spring内部中还是有使用了Dependency Lookup（依赖查找）方式的，如BeanFactoryAware、ApplicationContextAware，这些只是针对比较特殊处理，spring大部分还是使用DI方式。由于此书2004年就出版了，当时的JDK版本还没有注解，所以后来spring的版本DI的方式还有通过注解注入（包含field inject）。</p><h1 id="spring的两种容器"><a href="#spring的两种容器" class="headerlink" title="spring的两种容器"></a>spring的两种容器</h1><p>分析源码之前，把API转换成类图，这些容器之间的关系其实就比较清晰了。spring的IoC容器主要分为两类，一个是BeanFactory，一个是ApplicationContext，如下图所示（基于4.2.3分支）：</p><p><img src="/images/spring/1-2.png" alt></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory作为最顶层的工厂，只提供了获取bean最基本的操作，其他操作又抽象出了4个工厂：<br>HierarchicalBeanFactory：设置bean的一种层级关系，可以获取父类的BeanFactory（如果在当前容器中没有找到还可以到父类容器中去找bean）。<br>ListableBeanFactory：可以列举所有的bean的名字，在内部解析的时候，经常用到，但只会涉及到当前容器的bean，不会像HierarchicalBeanFactory去找父类BeanFactory的bean。<br> AutowireCapableBeanFactory：创建bean的工厂，bean的依赖实现也是由此工厂处理。<br>ConfigurableBeanFactory：一般与BeanFactory、ListableBeanFactory一起使用，设置一些初始化配置操作，包括bean是singleton还是prototype， setParentBeanFactory，setConversionService，addPropertyEditorRegistrar，registerCustomEditor，addBeanPostProcessor等等。</p><h3 id="AbstractBeanFactory"><a href="#AbstractBeanFactory" class="headerlink" title="AbstractBeanFactory"></a>AbstractBeanFactory</h3><p>BeanFactory的抽象实现类，实现了bean的判断以及获取bean的入口。</p><h3 id="AbstractAutowireCapableBeanFactory"><a href="#AbstractAutowireCapableBeanFactory" class="headerlink" title="AbstractAutowireCapableBeanFactory"></a>AbstractAutowireCapableBeanFactory</h3><p>处理bean的实例化操作，也包括处理前、处理后一些操作，在后面分析代理bean初始化再详细介绍。</p><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p>DefaultListableBeanFactory作为BeanFactory的具体实现类，是整个IoC容器最核心的一个类，只要涉及到容器，就离不开DefaultListableBeanFactory，该类实现了注册bean、缓存bean names（解析bean的时候用到），具体的的依赖关系参考下图：</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>相比BeanFactory，ApplicationContext继承了更多的接口，功能更强大，</p><ol><li>bean具有层级关系（父子关系）</li><li>可以触发监听事件</li><li>实现了ResoureLoader可以加载配置文件</li><li>默认注册PropertyEditors，由BeanWrapperImpl实现属性类型转换</li><li>内部实现了对BeanPostProcessor内置对象的处理<br>所以实际运用中，一般都使用的ApplicationContext类型的IoC容器</li></ol><h3 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h3><p>与AbstractBeanFactory一样，只要继承了AbstractApplicationContext，这个容器获取bean的入口就在这个抽象类中，可以参考refresh方法：</p><pre><code>@Overridepublic void refresh() throws BeansException, IllegalStateException {    synchronized (this.startupShutdownMonitor) {        // Prepare this context for refreshing.        prepareRefresh();        // Tell the subclass to refresh the internal bean factory.        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // Prepare the bean factory for use in this context.        prepareBeanFactory(beanFactory);        try {            // Allows post-processing of the bean factory in context subclasses.            postProcessBeanFactory(beanFactory);            // Invoke factory processors registered as beans in the context.            invokeBeanFactoryPostProcessors(beanFactory);            // Register bean processors that intercept bean creation.            registerBeanPostProcessors(beanFactory);            // Initialize message source for this context.            initMessageSource();            // Initialize event multicaster for this context.            initApplicationEventMulticaster();            // Initialize other special beans in specific context subclasses.            onRefresh();            // Check for listener beans and register them.            registerListeners();            // Instantiate all remaining (non-lazy-init) singletons.            finishBeanFactoryInitialization(beanFactory);            // Last step: publish corresponding event.            finishRefresh();        }        catch (BeansException ex) {            // Destroy already created singletons to avoid dangling resources.            destroyBeans();            // Reset &apos;active&apos; flag.            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        }    }}</code></pre><p>这个方法包含了初始化bean、实例化bean之前的一些操作、初始化国际化资源文件、注册各种监听器等等， AbstractApplicationContext内部存储bean其实都是由DefaultListableBeanFactory完成，后面bean分析的时候详细说明。</p><p>如果说得再细一点还可以把WebApplicationContext归为一类容器，但作为ApplicationContext的子类，里面的实现几乎没什么区别，只是WebApplicationContext里面多了对servlet相关类的处理，所以分为两大类就可以了。</p><p>总结<br>spring的IoC容器是整个框架最核心的部分，只要把这部分弄明白了，其他模块也就迎刃而解了，参考下图（来自spring官方文档）：</p><p><img src="/images/spring/1-3.png" alt></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《Expert One-on-One J2EE Design and Development》<br>《Expert One-on-One J2EE Development without EJB》<br>《Professional Java Development with the spring framework》</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis自定义插件实现读写分离</title>
      <link href="/2016/07/20/2.9mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2016/07/20/2.9mybatis%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>mybatis提供了Interceptor接口，这个接口在Executor、ParameterHandler、ResultSetHandler、StatementHandler四个类方法执行的时候进行拦截处理，通过自定义拦截器就可以改变原方法的一些行为，如读写分离、分页查询等，整个过程的执行流程如下图所示：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/2.9-1.png" alt></p><p>为了设置数据源简单点，自定义的拦截器可以和spring配合使用，实现spring的ApplicationContextAware接口（直接从容器中拿到数据源）就可以了，这里以拦截Executor为例，代码实现如下：</p><pre><code>@Intercepts({@Signature(      type= Executor.class,      method = &quot;query&quot;,      args = {MappedStatement.class,Object.class, RowBounds.class,ResultHandler.class})})public class MyInterceptor implements Interceptor, ApplicationContextAware {    public final Logger mylog = Logger.getLogger(MyInterceptor.class);    public ConcurrentHashMap&lt;String, Environment&gt; map = new ConcurrentHashMap&lt;&gt;();    @Override    public Object intercept(Invocation invocation) throws Throwable {        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];        Configuration configuration = mappedStatement.getConfiguration();        if (map.get(&quot;slave&quot;) == null) {            Environment defaultEnvironment = configuration.getEnvironment();            //获取从库的数据源            DataSource slaveDatasource = applicationContext.getBean(&quot;slaveDatasource&quot;,  DataSource.class);                        //设置从库的环境            Environment.Builder environmentBuilder = new Environment.Builder(defaultEnvironment.getId())                      .transactionFactory(defaultEnvironment.getTransactionFactory())                      .dataSource(slaveDatasource );            Environment slave = environmentBuilder.build();            map.put(&quot;slave&quot;, slave);        }        configuration.setEnvironment(map.get(&quot;slave&quot;));        return invocation.proceed();    }    @Override    public Object plugin(Object target) {        //将目标对象封装成代理对象        return Plugin.wrap(target, this);    }    @Override    public void setProperties(Properties properties) {    }    public void setApplicationContext(ApplicationContext applicationContext) {            this.applicationContext = applicationContext;    }}</code></pre><p>在配置文件中再配置下这个拦截器：</p><pre><code>&lt;plugins&gt;    &lt;plugin interceptor=&quot;atest.reopen.session.interceptor.MyInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p>查询的时候使用从库的数据源，这样就动态的实现了数据库的读写分离，这种实现方式看上去拦截粒度比较粗，如果有特殊查询不用从库的，也可以自定义一套规则，把这些特殊的查询排除掉。如果没有特别需求，我感觉这种方式是最方便的了，网上有些从spring aop级别去控制读写分离的，虽然粒度要精细一些，但是像读写分离这种，个人觉得还是越底层实现越好。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery插件扩展分析</title>
      <link href="/2016/07/07/4.1jQuery%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95%E5%88%86%E6%9E%90/"/>
      <url>/2016/07/07/4.1jQuery%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery对象简介"><a href="#jQuery对象简介" class="headerlink" title="jQuery对象简介"></a>jQuery对象简介</h1><p>在源码中看到jQuery对象其实就是第一个函数表达式，这个函数里面什么都没有干，直接返回了一个init实例化的对象，由于init的原型对象引用指向的就是jQuery，所以这个对象实际就是jQuery的实例。</p><a id="more"></a><!-- --- --><pre><code>jQuery = function( selector, context ) {    //创建jQuery实例    // The jQuery object is actually just the init constructor &apos;enhanced&apos;    // Need init if jQuery is called (just allow error to be thrown if not included)    return new jQuery.fn.init( selector, context );},...//jQuery的原型引用传递给jQuery.fnjQuery.fn = jQuery.prototype...// Give the init function the jQuery prototype for later instantiation//将jQuery原型引用传递给initinit.prototype = jQuery.fn;</code></pre><p>经过两次引用传递，init对象就具有jQuery对象的功能了，各个原型之间的关系参考下图：</p><p><img src="/images/web/jQuery/12-1.png" alt></p><p>JavaScript的原型分析可以参考前面的<a href="http://zeng233.github.io/2016/07/06/5.1%E7%90%86%E8%A7%A3JavaScript%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">《理解JavaScript原型模式》</a>。<br>将jquery.js引入文档之后，执行jQuery匿名函数的时候传递了window对象，把jQuery与$变量赋值给window，所以这两者通用的，都表示jQuery的实例化对象。我们代码里面就可以用jQuery.ajax()，jQuery.each()等原型中的方法了。</p><h1 id="jQuery两种添加插件方式"><a href="#jQuery两种添加插件方式" class="headerlink" title="jQuery两种添加插件方式"></a>jQuery两种添加插件方式</h1><p>jQuery里面有两种扩展可以实现自己的插件，一种是$.extend，另一种就是$.fn.extend，源代码里面它们其实指向同一个函数：</p><pre><code>jQuery.extend = jQuery.fn.extend = function() {    var src, copyIsArray, copy, name, options, clone,    target = arguments[0] || {},//返回的目标对象    i = 1,    length = arguments.length,    deep = false;    ......}</code></pre><p>从前面的分析大概就明白这两者的区别了，$.extend表示第一次加载进来的实例就添加一个extend函数，而$.fn.extend表示jQuery原型对象上面添加一个extend函数，所以在$.extend里面添加扩展函数可以直接用$.函数名()直接使用，而$.fn.extend需要执行$(选择器).函数名()实例化之后才可以调用扩展函数。可以简单的理解为，$.extend为jQuery全局对象添加方法，$.fn.extend为jQuery实例化添加方法。</p><h2 id="extend方式添加插件"><a href="#extend方式添加插件" class="headerlink" title="$.extend方式添加插件"></a>$.extend方式添加插件</h2><p>如果只添加一个参数相当于直接在jquery对象增加了一个属性，如果是多个参数，那么会合并到第一个参数，如：</p><p>1、直接添加对象属性为函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = $.extend(&#123;</span><br><span class="line">hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'t1 is executed'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在全局变量中添加了hello函数</span></span><br><span class="line"><span class="built_in">console</span>.log($.hello());</span><br></pre></td></tr></table></figure><p>这种方式就直接在jQuery全局对象上添加的函数。</p><p>2、另外一种就是拷贝对象</p><p><strong>深拷贝</strong>，只要对象里面还有对象，会递归的去复制到目标对象，并把以前的值覆盖掉</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var child</span> = &#123;name: <span class="string">'small'</span>, age: 1&#125;;</span><br><span class="line"><span class="attribute">var target</span> = &#123;foo: <span class="string">'duke'</span>, child: child&#125;;</span><br><span class="line"><span class="attribute">var opChild</span> = &#123;name:<span class="string">'sm'</span>, age:2&#125;;</span><br><span class="line"><span class="attribute">var option</span> = &#123;foo: <span class="string">'op'</span>, child:opChild&#125;;</span><br><span class="line"><span class="attribute">var result</span> = $.extend(target, &#123;foo: <span class="string">'success'</span>&#125;, option)</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>输出结果，：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//child的属性值全部被覆盖</span></span><br><span class="line">&#123;<span class="string">name:</span> <span class="string">"sm"</span>, <span class="string">age:</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>浅拷贝</strong>对象里面不嵌套的拷贝，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t3 = $.extend(&#123;<span class="string">'realname'</span>:<span class="string">'hello'</span>, <span class="string">'password'</span>: <span class="number">111111</span>&#125;, &#123;<span class="string">'password'</span>:<span class="string">'222222'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(t3);</span><br></pre></td></tr></table></figure><p>输入结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span> &#123;<span class="attribute">realname</span>: <span class="string">"hello"</span>, password: <span class="string">"222222"</span>&#125;</span><br></pre></td></tr></table></figure><p>这种参数扩展非常有用，在jquery插件中常常会用到默认有哪些参数值，然后用户调用的时候可以重写这些参数值，也可以增加额外的参数。</p><h2 id="fn-extend方式添加插件"><a href="#fn-extend方式添加插件" class="headerlink" title="$.fn.extend方式添加插件"></a>$.fn.extend方式添加插件</h2><p>前面已经介绍了，$.fn.extend与$.extend指向的是同一个函数，所以两者的功能是一样的，$.fn.extend只是针对原型对象的。写一个简单的扩展就明白了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">foo : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log($.foo)<span class="comment">//输出undefined</span></span><br><span class="line">$().foo();<span class="comment">//输出foo</span></span><br></pre></td></tr></table></figure><p>如果想支持链式调用，可以在自定义的函数里面return一个jquery原型对象就可以了。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.fn.extend(&#123;</span><br><span class="line">foo : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//this代表jQuery.prototype原型对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="built_in">document</span>).foo().empty();</span><br></pre></td></tr></table></figure><p>由于extend函数里面就是把传入的属性赋值给当前对象（jQuery实例或者jQuery原型对象），所以如果只是一个函数扩展的话，也可以直接这样定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.fn.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//this代表jQuery.prototype原型对象</span></span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="built_in">document</span>).foo().empty();</span><br></pre></td></tr></table></figure><h2 id="自定义插件标准"><a href="#自定义插件标准" class="headerlink" title="自定义插件标准"></a>自定义插件标准</h2><p>上面两种插件方式都是以直接传入参数形式进行扩展的，既然是扩展就应该遵守开闭原则，只对外就行修改，并且不能与原对象造成影响。所以自定义插件应该封装成一个类与外界保持独立，JavaScript虽然没有类但是有命名空间，可以为插件定义一个私有化空间，目前一般都采用匿名函数来定义，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    $.fn.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">$(<span class="built_in">document</span>).foo();<span class="comment">//输出foo</span></span><br></pre></td></tr></table></figure><p>可以看到匿名函数传入了jQuery对象，内部函数就可以共享jQuery的很多功能了，所以一般引入其他插件，有一个前提就是必须先引用jquery.js再引用插件的js文件。</p>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的this常见误区</title>
      <link href="/2016/07/06/5.2JavaScript%E4%B8%AD%E7%9A%84this%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"/>
      <url>/2016/07/06/5.2JavaScript%E4%B8%AD%E7%9A%84this%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中，this是函数中的一个特殊对象，它表示的是函数执行环境所在的环境对象。函数执行的时候会生成一个执行环境，这个执行环境又会包含在某个对象中，如：直接在脚本中声明一个函数再执行，那么这个环境对象就是window；在一个对象中执行函数，这个环境对象就是当前执行函数所在的对象。下面列出几种常见的陷阱：</p><a id="more"></a><!-- --- --><h1 id="函数传递中的this"><a href="#函数传递中的this" class="headerlink" title="函数传递中的this"></a>函数传递中的this</h1><pre><code>var name = &quot;The Window&quot;;    var object = {        name : &quot;My Object&quot;,        getName: function(){        return this.name;    }};(object.getName = object.getName)(); //&quot;The Window&quot;</code></pre><p>打印出来的结果是”The Window”，也许有点奇怪，但是按照上面的思路来分析，其实很简单，object.getName引用传递给本身，然后匿名函数在window环境中执行，上面的代码可以转换为：</p><pre><code>var name = &quot;The Window&quot;;    var object = {        name : &quot;My Object&quot;,        getName: function(){        return this.name;    }};object.getName = object.getName;var temp = object.getName;temp();//输出The Window</code></pre><p>这样转换之后就很清楚的看到，最后匿名函数的执行环境其实包含在window对象中的，所以输出的是The Window。</p><h1 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h1><pre><code>var name = &apos;global&apos;;function Person() {    var name = &apos;local&apos;;    console.log(this.name);}Person();//输出globalnew Person();//输出undefined</code></pre><p>如代码所示，第一次执行表示正常的函数执行，输出global没问题，第二个就纳闷了，怎么是undefined？new Person()是构造函数方式创建对象，有点特殊性，可以参考前面的《理解JavaScript原型模式》，可以这样理解，当执行new Person时会分配一个Person实例的内存空间，加上括号就执行Person构造函数，这时Person构造函数所属的对象就是新建的实例对象，而这个实例对象里面什么都没有，所以输出undefined了，如果想要输出属性值，就得给实例赋值，如：this.name=’local’赋值之后，创建的实例就可以输出local了。</p><h1 id="闭包中的this"><a href="#闭包中的this" class="headerlink" title="闭包中的this"></a>闭包中的this</h1><p>同样是上面的例子，直接把getName函数的返回值改成一个匿名函数：</p><pre><code>var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;,    getName: function(){        return function(innerName) {            console.log(this.name);//输出The Window        };    }};object.getName()(&apos;inner&apos;);</code></pre><p>如果不小心，单从object去分析就很容易出错，object.getName()(‘inner’)这段代码其实也是window对象中的一个匿名函数的执行，等价于：</p><pre><code>var temp = object.getName();//获得返回的匿名函数temp(&apos;inner&apos;);</code></pre><p>这样可以看到temp就是一个闭包，执行环境是在window对象中执行，所以this就是当前window全局变量了。</p><p>有时候在命名自己的私有空间时，也常常会用到闭包，下面再来一个闭包场景下的this：</p><pre><code>var name=&apos;global&apos;;var Global = (function() {    var name = &apos;local&apos;;    var getName = function() {        console.log(this.name);    }    return {        name : &apos;obj&apos;,        objGetName : getName    }})();Global.objGetName();//输出obj</code></pre><p>上面代码可以看出有3个name，看上去输出哪个name有点晕乎，前面说了只要记住函数执行环境所在的对象，不管嵌套多少个函数，其实分析起来都很简单的。这里我们看到会最先执行匿名函数，然后把返回的一个匿名对象赋值给Global对象，在返回对象中getName赋值给了objGetName，执行objGetName函数所在对象是Global，里面的this对象其实就变成了返回的匿名对象了，所以this.name表示的就是匿名对象中的name了。</p><h1 id="HTML事件绑定中的this"><a href="#HTML事件绑定中的this" class="headerlink" title="HTML事件绑定中的this"></a>HTML事件绑定中的this</h1><p>HTML元素其实都是一个对象，里面的各种事件就是函数，事件里面执行函数就相当于一个闭包，拿个例子来说：</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;nameInput&quot; onclick=&quot;this.value = 2&quot;/&gt;var nameInput = document.getElementById(&apos;nameInput&apos;);console.log(nameInput.onclick);//onclick属性是一个函数</code></pre><p>执行onclick事件时，执行函数环境就包含在input标签对象中了，所以事件中的this表示的就是input对象了。<br>如果onclick事件中嵌套一个函数，那这个函数中的this还是input对象么？</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;nameInput&quot; onclick=&quot;doAction()&quot;/&gt;&lt;br&gt;function doAction() {    var nameInput = document.getElementById(&apos;nameInput&apos;);    console.log(nameInput.onclick);//onclick属性是一个函数    console.log(this);//输出window对象    this.value = Math.random();}</code></pre><p>意料之中输出的是window对象，最简单粗暴的理解方式就是最后执行doAction函数所在对象是在window对象中，所以不用管onclick到底所属对象。可以换一种写法：</p><pre><code>function doAction() {    console.log(this);//输出window对象}function onclick() {    doAction();}var nameInput = document.getElementById(&apos;nameInput&apos;);nameInput.onclick();</code></pre><p>这样就可以更直观的看到其实就是一般的函数之间的调用了。如果想用onclick所在的html元素对象，就执行函数里面添加一个this参数就可以了，如：</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;nameInput&quot; onclick=&quot;doAction(this)&quot;/&gt;&lt;br&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解JavaScript原型模式</title>
      <link href="/2016/07/06/5.1%E7%90%86%E8%A7%A3JavaScript%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/07/06/5.1%E7%90%86%E8%A7%A3JavaScript%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="理解原型模式"><a href="#理解原型模式" class="headerlink" title="理解原型模式"></a>理解原型模式</h1><p>原型模式简单点说就是各个实例共享一个原型对象。JavaScript实现原型模式非常简单，直接用个prototype就实现了。新建实例里面保存了指针指向同一个原型对象，而与构造函数没有关系，参考原型图：</p><a id="more"></a><!-- --- --><p><img src="/images/web/JavaScript/13-1.png" alt></p><h1 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h1><h2 id="直接在原型对象里面添加属性和方法"><a href="#直接在原型对象里面添加属性和方法" class="headerlink" title="直接在原型对象里面添加属性和方法"></a>直接在原型对象里面添加属性和方法</h2><p>因为各个实例要共享一个原型对象，所以就把构造函数中的属性和方法集中到一个对象就可以了，如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span><span class="params">()</span> <span class="comment">&#123;&#125;</span>;</span></span><br><span class="line">Student.prototype.<span class="keyword">name</span> = <span class="string">'foo'</span>;</span><br><span class="line">Student.prototype.age = <span class="string">'1'</span>;</span><br><span class="line">Student.prototype.say = <span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="comment">&#123;console.log('hehe')&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">student</span> = <span class="title">new</span> <span class="title">Student</span><span class="params">()</span>;</span></span><br><span class="line">student.say();<span class="comment">//输出hehe</span></span><br><span class="line">console.log(student<span class="function">.<span class="keyword">constructor</span>);</span><span class="comment">//输出构造函数Student</span></span><br></pre></td></tr></table></figure><p>Student.prototype就是看做原型对象，在里面分别添加属性和方法就可以了。从上图中看到构造函数Student有一个prototype属性，这个属性就是指向原型对象Student.prototype的指针，执行student.say()这个实例方法，会先从实例对象student属性中去找有没有这个方法，如果没有再到原型对象里面去查询。</p><h2 id="重写原型对象"><a href="#重写原型对象" class="headerlink" title="重写原型对象"></a>重写原型对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> student1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(student1.name);<span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(student1.age);<span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(student1.say)<span class="comment">//输出undefined，没有重写原型对象之前，指针还是只想原来的原型对象</span></span><br><span class="line">Student.prototype = &#123;</span><br><span class="line">    <span class="comment">//constructor: Student,//强制将构造函数修改为Student</span></span><br><span class="line">    name:<span class="string">'foo'</span>,</span><br><span class="line">    age : <span class="string">'1'</span>,</span><br><span class="line">    say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hehe'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student2 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(student2.say);<span class="comment">//重写原型对象之后，新实例化对象指向重写后的原型对象</span></span><br><span class="line"><span class="built_in">console</span>.log(student2.constructor);<span class="comment">//重写原型对象后，构造函数变成了Object</span></span><br><span class="line">Student.prototype.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student2.foo);</span><br></pre></td></tr></table></figure><p>需要注意的是，如果在开始还没有重写原型对象时，实例化的对象是不能访问重写后Student.prototype里面的内容的，参考实例student1打印结果；如果重写了原型对象，再实例化student2，然后再对原型对象添加属性，student2是可以获得最新的原型对象，因为student2中只是保存的是重写后的原型对象指针，所以不管原型对象怎么修改，student2中的指针始终指向重写后的原型对象，如下图所示：</p><p><img src="/images/web/JavaScript/13-2.png" alt></p><h1 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h1><p>原型链继承记住一点就可以了，就是直接重写原型对象。其实前面重写Student原型对象就有点原型链的意思了，只不过是继承的Object不太容易看出来。下面定义两个对象，一个父对象，一个子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fvalue = <span class="string">'father'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Fathor.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cvalue = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.getChildValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与前面的重写Student.prototype是不是有点相似了</span></span><br><span class="line"><span class="comment">//这里不要加var，不然会先加载var变量，执行的时候就找不到Father了</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.getFatherValue());<span class="comment">//输出father</span></span><br></pre></td></tr></table></figure><p>参考资料：</p><p>-《JavaScript高级程序设计第三版》</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concurrent包分析之Executor框架</title>
      <link href="/2016/03/02/3.2concurrent2/"/>
      <url>/2016/03/02/3.2concurrent2/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么使用executor框架"><a href="#为什么使用executor框架" class="headerlink" title="为什么使用executor框架"></a>为什么使用executor框架</h1><ol><li>线程生命周期的开销：线程比较少的情况使用new Thread(task)无多大影响，但是如果涉及到线程比较多的情况，应用的性能就会受到影响，如果jdbc创建连接一样，new Thead创建线程也会耗资源、耗时间的。</li><li>资源的消耗量：活动线程会消耗系统性能，如果运行的线程数量多余可用的处理器数，那么就会有大量空闲的线程占用内存，会给垃圾收集器带来压力，如果有cpu资源竞争，还会有其他性能开销。</li><li>限定创建线程的数目：如果不设定创建线程的数量，一个任务一个线程无限创建线程，高负载情况下就有可能造成OutOfMemoryError错误。所以像tomcat这种servlet容器的线程池都设置了最大线程数量的。</li></ol><a id="more"></a><!-- --- --><h1 id="Executor框架组成"><a href="#Executor框架组成" class="headerlink" title="Executor框架组成"></a>Executor框架组成</h1><p>Eexecutor接口：包含Eexecutor、ExecutorService、ScheduledExecutorService<br>ThreadPool线程池：包含ThreadPoolExecutor、ScheduledThreadPoolExecutor<br>Fork/Join框架：JDK1.7新增<br>类之间的关系如下：<br><img src="/images/javaSE/concurrent/2-1.png" alt></p><p>Executor框架将线程的创建与执行解耦，可以异步调用，让任务相互独立，用阻塞队列管理任务，直接在当前线程中消费队列，可以减少线程之间进行资源竞争，也可以减少线程的创建和系统的开销，要廉价多了。这种设计就是经典并发模式Active Object Models（也称Actor Models）的实现，如下图：<br><img src="/images/javaSE/concurrent/2-2.png" alt><br>可以参考execute方法，就按照上面的模式来的。另外Executors工厂类创建了不同的连接池，为任务的执行分配了不同执行策略。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>concurrent包里面主要包含ThreadPoolExecutor、ScheduledThreadPoolExecutor两种线程池，Executors类提供了很多创建线程池的方法<br><img src="/images/javaSE/concurrent/2-3.png" alt><br>，newFixedThreadPool创建定长的线程池、newWorkStealingPool创建ForkJoinPool（jdk1.8新增）、newCachedThreadPool创建缓存线程池（可以回收空闲的线程）、newSingleThreadExecutor创建当个线程池（保证FIFO\LIFO\优先级），newScheduledThreadPool创建定时器线程池，如果有特殊处理的，也可以根据自己的需求来创建连接池，如tomcat也是基于ThreadPoolExecutor实现了自己的连接池。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><pre><code>public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue) {    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,     Executors.defaultThreadFactory(), defaultHandler);}</code></pre><p>从ThreadPoolExecutor最简单的构造函数可以看出，线程池总是依赖阻塞队列而工作的，newFixedThreadPool与newSingleThreadExecutor使用的是LinkedBlockingQueue无界队列，newCachedThreadPool使用SynchronousQueue，ThreadPoolExecutor还定义了一个Worker执行任务线程，除此之外，还有个非常重要的变量ctl（线程池控制状态）由执行器状态和工作线程的数量组成，在控制执行的时候都是围绕这个变量来判断。</p><h3 id="处理任务"><a href="#处理任务" class="headerlink" title="处理任务"></a>处理任务</h3><p>参考前面的Active Object Models图，可以将线程池执行任务主要分为3个步骤：<br>1、如果任务少于线程池大小时，就作为firstTask分别创建工作线程执行任务<br>2、如果第n个任务超出了线程池大小，就加入到阻塞队列，并从新检测执行器状态状态以及工作线程数量（有可能线程发生RuntimeException挂掉，最后可工作线程数量变为0），如果工作线程挂完了就重新启动一个线程（解决线程泄露问题）。阻塞队列的任务执行就在第一步所创建的线程执行，参考代码：</p><pre><code>public void execute(Runnable command) {    if (command == null)        throw new NullPointerException();    int c = ctl.get();    if (workerCountOf(c) &lt; corePoolSize) {        if (addWorker(command, true))            return;        c = ctl.get();    }    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {        int recheck = ctl.get();        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        else if (workerCountOf(recheck) == 0)            //重新启动工作线程            addWorker(null, false);    }    else if (!addWorker(command, false))        reject(command);}final void runWorker(Worker w) {    Thread wt = Thread.currentThread();    Runnable task = w.firstTask;    w.firstTask = null;    w.unlock(); // allow interrupts    boolean completedAbruptly = true;    try {        //判断当前任务或者检测阻塞队列        while (task != null || (task = getTask()) != null) {            w.lock();            // If pool is stopping, ensure thread is interrupted;            // if not, ensure thread is not interrupted.  This            // requires a recheck in second case to deal with            // shutdownNow race while clearing interrupt            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try {                beforeExecute(wt, task);                Throwable thrown = null;                try {                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    thrown = x; throw new Error(x);                } finally {                    afterExecute(task, thrown);                }            } finally {                task = null;                w.completedTasks++;                w.unlock();            }        }        completedAbruptly = false;    } finally {        processWorkerExit(w, completedAbruptly);    }}</code></pre><p>3、如果任务入队列失败了，就重新开启一个线程去执行，如果还是失败了，就可以确定是执行器关闭了或者线程池已经达到饱和状态了。</p><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>从上面的执行步骤来就可以看出线程池依赖于阻塞队列，然后基于生产者消费者模式实现的，execute()方法一直添加任务（生产者），当任务数量超出线程池的最大长度就添加到阻塞队列等待排队执行，而第一次创建的所有工作线程（最大数量为线程池的最大长度）就会一直判断线程池里面是否有任务执行，如果有就执行任务（消费者）。这样做就可以重用线程了，不用每次去创建线程，性能肯定比一个任务一个线程好多了。</p><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor由ScheduledFutureTask、DelayedWorkQueue组成，实现任务执行还是用的父类ThreadPoolExecutor的工作线程。jdk1.5之前使用定时任务都用的Timer，但是与ScheduledThreadPoolExecutor有着明显区别：</p><ol><li>Timer使用的System.currentTimeMillis()毫秒来控制时间，ScheduledThreadPoolExecutor使用System.nanoTime()纳秒控制更加精准，并且可以使用TimeUnit进行时间的跨单元转换。</li><li>Timer只有单个工作线程，ScheduledThreadPoolExecutor可以配置多个工作线程。</li><li>如果工资线程发生异常，Timer会造成线程泄露没有重启的线程，ScheduledThreadPoolExecutor会一直检测工作线程的数量，如果没有工作线程了，会一直添加数量小于线程池的工作线程（使用父类ThreadPoolExecutor的addaddWorker方法）<br>从以上比较可以看出，ScheduledThreadPoolExecutor就是取代Timer的。</li></ol><p>还是从一个简单的例子看ScheduledThreadPoolExecutor是如何工作的。addWork参考领导/跟随者模式</p><pre><code>@Testpublic void testScheduleAtFixedRate() throws Exception {    ScheduledThreadPoolExecutor p = new ScheduledThreadPoolExecutor(1);    CountDownLatch latch = new CountDownLatch(3);    p.scheduleAtFixedRate(new Task(latch), 0, 1000, TimeUnit.MILLISECONDS);    latch.await();}</code></pre><p>线程池都是基于生产者消费者模式的，所以ScheduledThreadPoolExecutor也不例外，执行任务的时候会一直像队列里面添加任务：</p><pre><code>private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {    if (isShutdown())        reject(task);    else {        //添加到队列，让工作线程去消费        super.getQueue().add(task);        if (isShutdown() &amp;&amp;            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;            remove(task))            task.cancel(false);        else            //启动线程            ensurePrestart();    }}</code></pre><p>ScheduledThreadPoolExecutor第一次执行用的父类ThreadPoolExecutor的addWorker方法添加工作线程并启动它，然后每个工作线程会检查队列里面是否有消费的线程，参考ThreadPoolExecutor的runWorker方法，与ThreadPoolExecutor有点不同的是，ScheduledThreadPoolExecutor使用的是延时阻塞队列DelayedWorkQueue。每次消费就进行take操作：</p><pre><code>public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        for (;;) {            RunnableScheduledFuture&lt;?&gt; first = queue[0];            if (first == null)                available.await();            else {                long delay = first.getDelay(NANOSECONDS);                if (delay &lt;= 0)                    //返回队列中的执行任务之前，要先执行finally模块中的唤醒操作                    return finishPoll(first);                first = null; // don&apos;t retain ref while waiting                if (leader != null)                    available.await();                else {                    //领导线程初始化为null，当前线程为线程池中的线程                    Thread thisThread = Thread.currentThread();                    leader = thisThread;                    try {                        //当前线程等待延迟时间到期                        available.awaitNanos(delay);                    } finally {                        if (leader == thisThread)                            leader = null;                    }                }            }        }    } finally {        if (leader == null &amp;&amp; queue[0] != null)            available.signal();        lock.unlock();    }}</code></pre><p>参考资料：</p><ul><li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp0730/index.html" target="_blank" rel="noopener">Java 理论与实践: 线程池与工作队列</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concurrent包分析之前言</title>
      <link href="/2016/03/01/3.1concurrent1/"/>
      <url>/2016/03/01/3.1concurrent1/</url>
      
        <content type="html"><![CDATA[<p>现在这个工作年限了，不会一点concurrent包中的东西都不好意思出去面试了,这也算是刺激学习concurrent包最大原因了。其实从java的发展历史来看，和collection包一样，concurrent包同样对JDK都产生了里程碑式的影响，Doug Lea设计的concurrent虽然没有像Josh Bloch那样获得Jolt大奖，但也算是业界神级一样的人物了，很多并发思想也值得借鉴。 也许在工作中用到并发的代码不多，但是也是非常重要的包，对研究其他的开源框架如tomcat、netty、zookeeper等也有帮助。</p><a id="more"></a><!-- --- --><p>与早期控制线程并发的wait(), notify(), and synchronized相比，concurrent包中的类实现更接近硬件、执行效率更高、 控制并发更简单，后面会逐步深入分析。concurrent包中的类大概只有70、80个类，参考Brian Goetz在JavaOne介绍concurrent的一个图：<br><img src="/images/javaSE/concurrent/1-1.png" alt></p><p>主要的类大概就这几十个，其实DougLea最初设计的时候总结起来就三大块：执行器框架、并发集合与同步器<br><img src="/images/javaSE/concurrent/1-2.png" alt></p><p>而整个concurrent包都是基于原子性的，那整个包的结构就变得比较清楚了，后期就针对这几块或者个别类进行深入分析。</p><p>参考资料：</p><ul><li>Doug Lea的《Concurrent Programming in Java, Second Edition》，多线程设计原理以及concurrent包的一些设计思路</li><li>并发专家Brian Goetz等著作的《JAVA并发编程实践》，地球人都知道</li><li>《面向模式的软件体系结构（卷2）》，并发相关的模式，concurrent包里面一些思想借鉴于此</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之mybatis使用到的设计模式</title>
      <link href="/2015/11/20/2.8mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bmybatis%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/11/20/2.8mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bmybatis%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>理解设计模式的最好方法就是在实际框架代码中去学习，看别人是怎么实现的，以及在哪种场景中使用这种模式。mybatis源码中也使用了一些设计模式，把目前发现的模式做个记录：</p><a id="more"></a><!-- --- --><h1 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h1><h2 id="工厂方法模式（Factory-Method-pattern）"><a href="#工厂方法模式（Factory-Method-pattern）" class="headerlink" title="工厂方法模式（Factory Method pattern）"></a>工厂方法模式（Factory Method pattern）</h2><p>一对一的关系，一个工厂创建一个与其对应的对象，由子类实现创建对象的操作：</p><p><img src="/images/mybatis/9-1.png" alt></p><p>参考JdbcTransactionFactory和DefaultObjectFactory.create()，DefaultObjectFactory.create()代码实现如下：</p><pre><code>@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {    Class&lt;?&gt; classToCreate = resolveInterface(type);    // we know types are assignable    return (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);}</code></pre><h2 id="建造者模式（Builder-pattern）"><a href="#建造者模式（Builder-pattern）" class="headerlink" title="建造者模式（Builder pattern）"></a>建造者模式（Builder pattern）</h2><p>创建的对象属性比较复杂，要分步骤处理，还是就是构造函数传的参数比较多的情况，对构造函数进行拆分，最后返回一个对象。</p><p><img src="/images/mybatis/9-2.png" alt></p><p>具体实现也可以不用抽象的Builder，视具体情况而定，可以参考ResultMap：</p><pre><code>public ResultMap build() {      if (resultMap.id == null) {        throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);      }      resultMap.mappedColumns = new HashSet&lt;String&gt;();      resultMap.idResultMappings = new ArrayList&lt;ResultMapping&gt;();      resultMap.constructorResultMappings = new ArrayList&lt;ResultMapping&gt;();      resultMap.propertyResultMappings = new ArrayList&lt;ResultMapping&gt;();      for (ResultMapping resultMapping : resultMap.resultMappings) {          //判断是内嵌查询还是内嵌结果集        resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;        resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;&amp; resultMapping.getResultSet() == null);        final String column = resultMapping.getColumn();        if (column != null) {            //将内部标签属性为column的添加早已映射列          resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));        } else if (resultMapping.isCompositeResult()) {          for (ResultMapping compositeResultMapping : resultMapping.getComposites()) {            final String compositeColumn = compositeResultMapping.getColumn();            if (compositeColumn != null) {              resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));            }          }        }        if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {          resultMap.constructorResultMappings.add(resultMapping);        } else {          resultMap.propertyResultMappings.add(resultMapping);        }        if (resultMapping.getFlags().contains(ResultFlag.ID)) {          resultMap.idResultMappings.add(resultMapping);        }      }      if (resultMap.idResultMappings.isEmpty()) {        resultMap.idResultMappings.addAll(resultMap.resultMappings);      }      // lock down collections      resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);      resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);      resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);      resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);      resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);      return resultMap;    }}</code></pre><h1 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h1><p>组织各个独立的对象，形成一个更强大的对象。</p><h2 id="装饰器模式（Decorator-pattern）"><a href="#装饰器模式（Decorator-pattern）" class="headerlink" title="装饰器模式（Decorator pattern）"></a>装饰器模式（Decorator pattern）</h2><p>通过传入的委派对象，去改变本身对象的责任与行为：</p><p><img src="/images/mybatis/9-3.png" alt></p><p>参考执行器CachingExecutor、以及缓存实现都用了装饰器模式，CachingExecutor就是一个装饰对象代码如下，通过构造函数传入委派对象Executor ：</p><pre><code>public class CachingExecutor implements Executor {    private static final Logger log = LoggerFactory.getLogger(CachingExecutor.class);  private Executor delegate;  private TransactionalCacheManager tcm = new TransactionalCacheManager();  public CachingExecutor(Executor delegate) {    this.delegate = delegate;    delegate.setExecutorWrapper(this);  }......}</code></pre><h2 id="动态代理模式（Proxy-pattern）"><a href="#动态代理模式（Proxy-pattern）" class="headerlink" title="动态代理模式（Proxy pattern）"></a>动态代理模式（Proxy pattern）</h2><p>由JDK的Proxy对象生成代理对象，运行期间动态执行目标方法。</p><p><img src="/images/mybatis/9-4.png" alt></p><p>参考MapperProxyFactory（相当于客户端）、MapperProxy（代理对象）、SqlSession（委派执行对象），MapperProxy执行源码：</p><pre><code>@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    if (Object.class.equals(method.getDeclaringClass())) {      try {        return method.invoke(this, args);      } catch (Throwable t) {        throw ExceptionUtil.unwrapThrowable(t);      }    }    //缓存真实调用方法，args为真实方法的参数    final MapperMethod mapperMethod = cachedMapperMethod(method);    log.debug(&quot;执行Mapper类中的方法&quot;);    return mapperMethod.execute(sqlSession, args);}</code></pre><p>此外mybatis的logging包下面的ConnectionLogger、PreparedStatementLogger、ResultSetLogger等都是动态代理对象。</p><p>参考资料：维基百科<a href="https://en.wikipedia.org/wiki/Creational_pattern" target="_blank" rel="noopener">Creational pattern</a>、<a href="https://en.wikipedia.org/wiki/Structural_pattern" target="_blank" rel="noopener">Structural pattern</a>、<a href="https://en.wikipedia.org/wiki/Behavioral_pattern" target="_blank" rel="noopener">Behavioral pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之Nested Select、Nested Results以及N+1问题分析</title>
      <link href="/2015/10/20/2.7mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BNested%20Select%E3%80%81Nested%20Results%E4%BB%A5%E5%8F%8AN+1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2015/10/20/2.7mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BNested%20Select%E3%80%81Nested%20Results%E4%BB%A5%E5%8F%8AN+1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>官方文档介绍ResultMap标签时，用了比较大的篇幅说明这个属性的强大与重要性，但也是最复杂的：</p><blockquote><p>The resultMap element is the most important and powerful element in MyBatis. It’s what allows you to do away with 90% of the code that JDBC requires to retrieve data from ResultSets, and in some cases allows you to do things that JDBC does not even support. In fact, to write the equivalent code for something like a join mapping for a complex statement could probably span thousands of lines of code. The design of the ResultMaps is such that simple statements don’t require explicit result mappings at all, and more complex statements require no more than is absolutely necessary to describe the relationships.</p></blockquote><blockquote><p><strong>Advanced Result Maps</strong><br>MyBatis was created with one idea in mind: Databases aren’t always what you want or need them to be. While we’d love every database to be perfect 3rd normal form or BCNF, they aren’t. And it would be great if it was possible to have a single database map perfectly to all of the applications that use it, it’s not. Result Maps are the answer that MyBatis provides to this problem.</p></blockquote><a id="more"></a><!-- --- --><p>从上面可以了解到ResultMap牛X的一点就是让结果集实现<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">3NF</a>，又要去翻书了o(╯□╰)o。mybatis映射结果集有两种形式，第一种使用resultType属性，其值为结果集类的别名或者全路径的类名，第二种为resultMap,其值为mapper.xml中<resultMap>标签的引用（用的id去标识），两种形式不能同时出现。resultType就直接和类映射就完了，比较简单不做太多分析，后面主要重点分析resultMap标签。<br>resultMap也包含多个内嵌标签：</resultMap></p><ul><li>constructor 构造器注入</li><li>id 结果集的唯一标示，一般用主键，提高性能</li><li>result 对应column属性</li><li>association 一对一实体关联属性，针对单个实体 </li><li>collection 一对多实体管理属性，针对集合</li><li>discriminator 结果集鉴别起，类似于SQL的when case功能</li><li>extends mybatis3以上也支持继承resultMap</li></ul><h1 id="ResultMap-demo分析"><a href="#ResultMap-demo分析" class="headerlink" title="ResultMap demo分析"></a>ResultMap demo分析</h1><p>针对关联查询，使用resultMap标签处理结果集会有两种方式：<br><strong>Nested Select</strong>：关联查询分成多条SQL执行，然后把关联表的结果集依次返回来（嵌套层级递推结果集）<br><strong>Nested Results</strong>：一条关联SQL执行，然后结果集由resultMap映射处理<br>这两种处理方式，上面的引用也说明了不用定义额外的结果集映射，只要在实体里面配置好映射关系即可。</p><h2 id="Nested-Select分析"><a href="#Nested-Select分析" class="headerlink" title="Nested Select分析"></a>Nested Select分析</h2><p>以blog、Author一对一关系为例分析：</p><pre><code>&lt;resultMap id=&quot;resultBlog&quot; type=&quot;atest.reopen.session.nestedResult.blog.Blog&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;idBlog&quot; /&gt;    &lt;result property=&quot;name&quot; column=&quot;blogname&quot; /&gt;    &lt;result property=&quot;url&quot; column=&quot;blogurl&quot; /&gt;    &lt;association property=&quot;author&quot; column=&quot;idBlog&quot; javaType=&quot;atest.reopen.session.nestedResult.blog.Author&quot; select=&quot;selectAuthor&quot; /&gt;    &lt;collection property=&quot;posts&quot; column=&quot;idBlog&quot; javaType=&quot;ArrayList&quot;        ofType=&quot;atest.reopen.session.nestedResult.blog.Post&quot; select=&quot;selectPosts&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectAuthor&quot; parameterType=&quot;int&quot; resultType=&quot;atest.reopen.session.nestedResult.blog.Author&quot;&gt;    SELECT idAuthor as id, name, email FROM t_AUTHOR WHERE idBlog = #{idBlog}&lt;/select&gt;&lt;select id=&quot;selectBlog&quot; resultMap=&quot;resultBlog&quot;&gt;    SELECT idBlog, name as blogname, url as blogurl FROM t_BLOG&lt;/select&gt;</code></pre><p>当表中数据量非常大时，这种方式就非常悲剧了，当一条SQL查询出多条Blog时，还要用成千上万的外键id去查询Author，这样会执行很多查询语句造成性能非常差，造成了N+1问题，虽然mybatis有延时加载功能可以减少点SQL语句执行，但是项目中不推荐使用这种。nested result就是对这种查询的改进，用SQL去关联查询，而不是在resultMap标签中通过select去执行SQL关联。</p><h2 id="Nested-Results分析"><a href="#Nested-Results分析" class="headerlink" title="Nested Results分析"></a>Nested Results分析</h2><pre><code>&lt;resultMap id=&quot;resultBlog&quot; type=&quot;atest.reopen.session.nestedResult.blog.Blog&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;idBlog&quot; /&gt;    &lt;result property=&quot;name&quot; column=&quot;blogName&quot; /&gt;    &lt;result property=&quot;url&quot; column=&quot;url&quot; /&gt;    &lt;association property=&quot;author&quot; column=&quot;idBlog&quot; javaType=&quot;atest.reopen.session.nestedResult.blog.Author&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;idAuthor&quot; /&gt;        &lt;result property=&quot;name&quot; column=&quot;authorName&quot; /&gt;        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;    &lt;/association&gt;    &lt;collection property=&quot;posts&quot; column=&quot;idBlog&quot; javaType=&quot;ArrayList&quot;        ofType=&quot;atest.reopen.session.nestedResult.blog.Post&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;idPost&quot; /&gt;        &lt;result property=&quot;title&quot; column=&quot;title&quot; /&gt;        &lt;collection property=&quot;tags&quot; column=&quot;idBlog&quot; javaType=&quot;ArrayList&quot;            ofType=&quot;atest.reopen.session.nestedResult.blog.Tag&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;idTag&quot; /&gt;            &lt;result property=&quot;value&quot; column=&quot;value&quot; /&gt;        &lt;/collection&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectBlog&quot; resultMap=&quot;resultBlog&quot;&gt;    SELECT    B.idBlog as idBlog, B.name as blogName, B.url as url,    A.idAuthor as idAuthor, A.name as authorName, A.email as email ,    P.idPost as idPost, P.title as title,    T.idTag as idTag, T.value as value    FROM t_BLOG as B    left outer join t_Author A on B.idBlog = A.idBlog    left outer join t_Post P on P.idBlog = B.idBlog    left outer join t_Post_Tag PT on P.idPost = PT.idPost    left outer join t_Tag T on PT.idTag = T.idTag&lt;/select&gt;</code></pre><p>与Nested Select不同的一点就是这里只嵌入了结果集，去掉了select，这样执行一条SQL就搞定了，避免了N+1问题。不管Nested Select还是Nested Result，id属性的值最好是主键，即使有联合主键的也用主键，这样性能会更好。<br>一对多跟一对一差不多，这里不分析了，下面直接分析源代码，看内部是如何实现的。</p><h1 id="解析resultMap标签源码分析"><a href="#解析resultMap标签源码分析" class="headerlink" title="解析resultMap标签源码分析"></a>解析resultMap标签源码分析</h1><p>首先XMLMapperBuilder解析resultMap标签，再遍历其子标签解析后的子标签属性都保存在ResultMapping中，有内嵌查询的其id就为命名空间+select属性的值，内嵌resultMap的id就为命名空间+子标签resultMap的Id，如果Nested Results这种方式association标签没有resultmap属性，直接用的javaType，那构造resultMap的id就由mybatis自定义生成id的方法生成，生成id的目的就是在构造最后的结果集处理的resultMap里面判断是Nested Select还是Nested Results，参考XMLMapperBuilder：</p><pre><code>private String processNestedResultMappings(XNode context, List&lt;ResultMapping&gt; resultMappings) throws Exception {    if (&quot;association&quot;.equals(context.getName())        || &quot;collection&quot;.equals(context.getName())        || &quot;case&quot;.equals(context.getName())) {      if (context.getStringAttribute(&quot;select&quot;) == null) {    //如果不是Nest Select就构造子结果集对象的ResultMap        ResultMap resultMap = resultMapElement(context, resultMappings);        return resultMap.getId();      }    }    return null;}</code></pre><p>MapperBuilderAssistant完成子resultMap的构建：</p><pre><code>public ResultMapping buildResultMapping(  Class&lt;?&gt; resultType,  String property,  String column,  Class&lt;?&gt; javaType,  JdbcType jdbcType,  String nestedSelect,  String nestedResultMap,  String notNullColumn,  String columnPrefix,  Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,  List&lt;ResultFlag&gt; flags,  String resultSet,  String foreignColumn,   boolean lazy) {    Class&lt;?&gt; javaTypeClass = resolveResultJavaType(resultType, property, javaType);    TypeHandler&lt;?&gt; typeHandlerInstance = resolveTypeHandler(javaTypeClass, typeHandler);    List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);    if (composites.size() &gt; 0) {      column = null;    }    ResultMapping.Builder builder = new ResultMapping.Builder(configuration, property, column, javaTypeClass);    builder.jdbcType(jdbcType);    //nestSelect    builder.nestedQueryId(applyCurrentNamespace(nestedSelect, true));    //nestResult    builder.nestedResultMapId(applyCurrentNamespace(nestedResultMap, true));    builder.resultSet(resultSet);    builder.typeHandler(typeHandlerInstance);    builder.flags(flags == null ? new ArrayList&lt;ResultFlag&gt;() : flags);    builder.composites(composites);    builder.notNullColumns(parseMultipleColumnNames(notNullColumn));    builder.columnPrefix(columnPrefix);    builder.foreignColumn(foreignColumn);    builder.lazy(lazy);    return builder.build();}</code></pre><p>由ResultMapResolver对resultMap进行实例化，并判断子标签是Nested Select还是Nested Results，XMLMapperBuilder在解析的时候完成：</p><pre><code>private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception {    。。。    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);    try {      return resultMapResolver.resolve();    } catch (IncompleteElementException  e) {      configuration.addIncompleteResultMap(resultMapResolver);      throw e;    }}</code></pre><p>resultMapResolver.resolve()就不贴源代码了，里面由ResultMap.build()完成一些子属性的判断以及实例化，最终构建好的ResultMap对象就被保存到Configuration对象，初始化ResultMap就完成了。</p><h2 id="Nested-Select的结果集处理"><a href="#Nested-Select的结果集处理" class="headerlink" title="Nested Select的结果集处理"></a>Nested Select的结果集处理</h2><p>最后查询结果集都在DefaultResultSetHandler进行处理，由于执行的方法比较多，画时序图不怎么好看，直接上类图了，便于理解，只要是执行方法就在DefaultResultSetHandler里面依次执行，在处理结果集的时候就会判断是内嵌查询还是内嵌结果集处理，参考代码：</p><pre><code>private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {    //初始化resultMap的时候设置是否是内嵌结果集    if (resultMap.hasNestedResultMaps()) {      ensureNoRowBounds();      checkResultHandler();      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);    } else {      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);    }}  </code></pre><p>如果是内嵌查询，如果要执行延时加载，mybatis全局里面要配置lazyLoadingEnabled，aggressiveLazyLoading（控制属性的延时加载），延时加载以cglib为例进行分析，如下图所示：</p><p><img src="/images/mybatis/8-1.png" alt></p><p>结果集就由createResultObject生成， 方法返回的resultObject就是查询后的对象，由反射累DefaultObjectFactory实现，这样结果实体即使没有定义set方法也可以设置到值，在处理每一列的时候会判断是不是嵌套查询，参考源代码：</p><pre><code>private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException {    final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;Class&lt;?&gt;&gt;();    final List&lt;Object&gt; constructorArgs = new ArrayList&lt;Object&gt;();    final Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);    if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {      final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();      for (ResultMapping propertyMapping : propertyMappings) {        // issue gcode #109 &amp;&amp; issue #149        if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) {        //结果集对象延时加载初始化          return configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);        }      }    }    return resultObject;}</code></pre><p>如果结果集对象在执行其关联对象的属性方法时就会触发延时加载，如blog.getAuthor().getId()，就会触发EnhancedResultObjectProxyImpl类的intercept方法：</p><pre><code>@Overridepublic Object intercept(Object enhanced, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {      final String methodName = method.getName();      try {        synchronized (lazyLoader) {          if (WRITE_REPLACE_METHOD.equals(methodName)) {            Object original = null;            if (constructorArgTypes.isEmpty()) {              original = objectFactory.create(type);            } else {              original = objectFactory.create(type, constructorArgTypes, constructorArgs);            }            PropertyCopier.copyBeanProperties(type, enhanced, original);            if (lazyLoader.size() &gt; 0) {              return new CglibSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);            } else {              return original;            }          } else {            if (lazyLoader.size() &gt; 0 &amp;&amp; !FINALIZE_METHOD.equals(methodName)) {                log.debug(&quot;cglib：lazyLoadTriggerMethods判断是全局延时加载还是局部延时加载&quot;);              if (aggressive || lazyLoadTriggerMethods.contains(methodName)) {                lazyLoader.loadAll();              } else if (PropertyNamer.isProperty(methodName)) {                final String property = PropertyNamer.methodToProperty(methodName);                if (lazyLoader.hasLoader(property)) {                    log.debug(&quot;cglib：ResultObject调用属性的方法就开始触发延时加载&quot;);                  lazyLoader.load(property);                }              }            }          }        }        return methodProxy.invokeSuper(enhanced, args);      } catch (Throwable t) {        throw ExceptionUtil.unwrapThrowable(t);      }    }}</code></pre><p>然后在ResultLoaderMap里面重新实例化一个executor（防止线程不安全）实例化，最后由ResultLoader去完成查询，这里的ResultLoader相当于SqlSession的角色，延时加载就分析完了，所以在执行内嵌查询的时候，在mybatis的全局一定要配置lazyLoadingEnabled为true，aggressiveLazyLoading为false（局部延时加载），这样才可以减少SQL的执行。</p><h2 id="Nested-Results的结果集处理"><a href="#Nested-Results的结果集处理" class="headerlink" title="Nested Results的结果集处理"></a>Nested Results的结果集处理</h2><p>如前面内嵌查询分析所示，在处理结果集有个判断，如果是内嵌结果集就由handleRowValuesForNestedResultMap方法处理了，后期有时间再补上这块的详细分析。。。<br>TODO</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之sql语句中#{}与${}表达式分析</title>
      <link href="/2015/10/15/2.6mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bsql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2015/10/15/2.6mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bsql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>最开始学习mybatis的时候对这两个表达式有疑惑，但一直没有深入去研究，直到最近的一个项目，测试安全的同学测试到有SQL入侵的问题，那时心里就下决心一定要把这个问题搞明白，虽然看似非常初级的一个小问题，但作为一个互联网项目却是致命的错误。记得以前在W公司工作的时候，有个同事因为没有使用占位符，而直接使用SQL拼接的方式去执行，虽然使用spring的jdbctemplate，但是原理一样，后面这个同事还被单独拉到办公室去痛批一顿。反正不管什么数据层的框架，只要涉及到SQL的都应该选择底层是PreparedStatement设置参数的方式去执行。其实在mybatis的wiki上面已经说得非常清楚了，使用${}表达式会有SQL入侵的风险，参考<a href="https://github.com/mybatis/mybatis-3/wiki/FAQ" target="_blank" rel="noopener">mybatis FAQ</a>，所以有必要单独拿出来分析。</p><a id="more"></a><!-- --- --><p>由于前面的章节已经分析了SQL语句的生成，参考<a href="http://zeng233.github.io/2015/09/28/2.4mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90/">动态SQL语句分析</a>，在解析sql标签的时候就可以初步看到两者的区别了，XMLScriptBuilder执行parseDynamicTags方法的时候，具体实现参考源代码：</p><pre><code>List&lt;SqlNode&gt; parseDynamicTags(XNode node) {    List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;();    NodeList children = node.getNode().getChildNodes();    for (int i = 0; i &lt; children.getLength(); i++) {      XNode child = node.newXNode(children.item(i));      if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) {        String data = child.getStringBody(&quot;&quot;);        TextSqlNode textSqlNode = new TextSqlNode(data);        //如果包含${}表达式会先检查，如果有就使用TextSqlNode，否则StaticTextSqlNode        if (textSqlNode.isDynamic()) {          contents.add(textSqlNode);          isDynamic = true;        } else {            //解析之后最终的SqlNode为StaticTextSqlNode          contents.add(new StaticTextSqlNode(data));        }      } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // issue #628        String nodeName = child.getNode().getNodeName();        NodeHandler handler = nodeHandlers(nodeName);        if (handler == null) {          throw new BuilderException(&quot;Unknown element &lt;&quot; + nodeName + &quot;&gt; in SQL statement.&quot;);        }        //动态sql封装        handler.handleNode(child, contents);        isDynamic = true;      }    }    return contents;}</code></pre><p>注意<strong>textSqlNode.isDynamic()</strong>这个判断，解析到xml的文本时，每次都要去判断是不是动态的，判断的依据就是文本SQL语句中是否包含${…}表达式，参考TextSqlNode的isDynamic方法：</p><pre><code>public boolean isDynamic() {    DynamicCheckerTokenParser checker = new DynamicCheckerTokenParser();    GenericTokenParser parser = createParser(checker);    //有${}占位符的就是动态语句，GenericTokenParser解析的时候，就用handleToken方法处理    //DynamicCheckerTokenParser实现了TokenHandler接口，handleToken方法就把isDynamic的值设置为true    parser.parse(text);    return checker.isDynamic();}</code></pre><p>最终有${}表达式的文本节点会保存到TextSqlNode，而#{}表达式的文本节点保存到StaticTextSqlNode，打开源代码看StaticTextSqlNode除了拼接sql时调用了DynamicContext的appendSql方法其他什么事情也没做。上面的步骤只是在解析xml节点，还没有真正生成可执行的SQL语句，参考动态SQL语句分析的章节的uml就一目了然了。</p><p>解析后完sql语句的xml节点最终都会保存到MixedSqlNode，不管是动态SQL语句还是静态SQL语句，在执行的时候，都要执行MixedSqlNode.apply(dynamicContext)方法去生成可执行的SQL语句。mybatis也提供了LanguageDriver接口，可以实现自定义解析xml的实现，如使用Velocity、FreeMarker等。</p><p>DynamicSqlSource或者RawSqlSource拼接sql语句时，执行MixedSqlNode.apply(dynamicContext)方法，把保存的所有节点循环执行，如前面所诉，包含${…}表达式的会使用TextSqlNode.apply()执行，参考源代码：</p><pre><code>@Overridepublic boolean apply(DynamicContext context) {    GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter));    context.appendSql(parser.parse(text));    return true;}</code></pre><p>在解析文本的时候，TextSqlNode中有个内部类BindingTokenParser，这个类就负责把${}表达式替换成具体的值，也就是说在拼接SQL的时候就把值传进去了，参考BindingTokenParser.handleToken方法：</p><pre><code>@Overridepublic String handleToken(String content) {  Object parameter = context.getBindings().get(&quot;_parameter&quot;);  if (parameter == null) {    context.getBindings().put(&quot;value&quot;, null);  } else if (SimpleTypeRegistry.isSimpleType(parameter.getClass())) {    context.getBindings().put(&quot;value&quot;, parameter);  }  Object value = OgnlCache.getValue(content, context.getBindings());  String srtValue = (value == null ? &quot;&quot; : String.valueOf(value)); // issue #274 return &quot;&quot; instead of &quot;null&quot;  checkInjection(srtValue);  return srtValue;}</code></pre><p>底层使用的OGNL表达式获取到具体的值，SQL入侵问题就出现在这里，表达式中的值可以写入类似or 1=1这种SQL片段，而使用#{}表达式的文本节点包含到StaticTextSqlNode，查看StaticTextSqlNode的apply方法，其实什么事情都没有做，只是一个拼接SQL字符串就没做其他事情了，然后由SqlSourceBuilder的内部类ParameterMappingTokenHandler将#{}替换成？占位符，最终参数中的各种handler将参数设值到PreparedStatement。更直观一点的方式就是查看执行前的SQL是什么样子的，在PreparedStatementHandler实例化statement的时候可以把SQL打印出来，参考源代码：</p><pre><code>@Overrideprotected Statement instantiateStatement(Connection connection) throws SQLException {  log.debug(&quot;statement：预处理，获取sql并返回Statement&quot;);    String sql = boundSql.getSql();    log.debug(&quot;statement：sql语句为 &quot; + boundSql.getSql());    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {      String[] keyColumnNames = mappedStatement.getKeyColumns();      if (keyColumnNames == null) {        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);      } else {        return connection.prepareStatement(sql, keyColumnNames);      }    } else if (mappedStatement.getResultSetType() != null) {      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);    } else {      return connection.prepareStatement(sql);    }}</code></pre><p>简单的一句话总结就是，${}表达式是一个字符串截取，在sql执行前会被参数值替换，而#{}表达式只是把里面的参数替换成问号（?）。<br>mybatis针对${}入侵也有具体措施，参考<a href="https://github.com/mybatis/mybatis-3/issues/117" target="_blank" rel="noopener">issues 117</a>，但是在最新版中的Configuration也没有setInjectionFilterEnabled、setInjectionFilter方法，反正不到万不得已，千万别使用${}表达式，最后引用mybatis wiki上面的的一句话：</p><blockquote><p>Important: note that use of ${…} (string substitution) presents a risk for SQL injection attacks. Also, string substitution can be problematical for complex types like dates. For these reasons, we recommend using the #{…} form whenever possible.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之反射包分析</title>
      <link href="/2015/10/07/2.5mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E5%B0%84%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>/2015/10/07/2.5mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E5%B0%84%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>mybatis解析xml时完成参数对象或者结果集对象等初始化，在执行流程中又要去动态修改这些对象的属性，所以单独设计了一套反射工具包，这些类封装在reflection包中，mybatis处理SQL参数或者结果集的时候几乎都有反射包的身影，这些主要类之间的依赖关系如下：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/6-1.png" alt></p><p>以SystemMetaObject.forObject(Object object)为入口，获取到MetaObject，以后目标对象的get、set方法都在MetaObject中执行了。<br>以正常的javabean对象为例子分析，执行MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY);方法判断object对象，是集合类型还是Javabean类型，如果是Javabean类型，就实例化BeanWrapper等对象，主要类之间的依赖关系如图所示，大概描述下这几个类的作用：<br><strong>MetaObject</strong>：根据目标对象类型，实例化不同的ObjectWrapper，还可以处理如XX.xx传入这种属性名的处理，以后调用get、set方法都用这个类，XX.xx属性内部代码实现：</p><pre><code>public void setValue(String name, Object value) {    PropertyTokenizer prop = new PropertyTokenizer(name);    if (prop.hasNext()) {       //处理XX.xx属性，先判断XX是什么类型的ObjectWrapper，如果是对象就返回SystemMetaObject.NULL_META_OBJECT，Map返回MapWrapper，List返回ObjectWrapper      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());      if (metaValue == SystemMetaObject.NULL_META_OBJECT) {        if (value == null &amp;&amp; prop.getChildren() != null) {          // don&apos;t instantiate child path if value is null          return;        } else {            //XX类的set方法设置，并返回这个类的MetaValue（用于子属性的设置set方法设置）          metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);        }      }      metaValue.setValue(prop.getChildren(), value);    } else {      objectWrapper.set(prop, value);    }}</code></pre><p><strong>BeanWrapper</strong>：符合Javabean规范对象的封装类，通过MetaClass获取到Invoker对象，再调用method.invoke()方法执行原对象的内部方法.</p><p><strong>PropertyTokenizer</strong>：属性分割解析器，可以处理多种参数写法，如：richType.richField、richMap.key、richMap[key]（Map类型属性）、richType.richMap[key]、richList[0]（List类型属性）、richType.richList[0]</p><p><strong>DefaultObjectFactory</strong>：通过反射实例化类，可以修改构造函数的访问权限</p><p><strong>MetaClass</strong>：通过传入目标对象的Class对象，Reflector对属性进行一些操作封装</p><p><strong>Reflector</strong>：真正对接JDK接口实现反射的工具类，目标对象初始化时就把所有的get，set方法装进map，如果属性没有get\set方法，反射原理设置get/set方法，并把方法保存到map中，具体代码实现：</p><pre><code>private void addFields(Class&lt;?&gt; clazz) {    Field[] fields = clazz.getDeclaredFields();    for (Field field : fields) {      if (canAccessPrivateMethods()) {        try {          field.setAccessible(true);        } catch (Exception e) {          // Ignored. This is only a final precaution, nothing we can do.        }      }      if (field.isAccessible()) {        if (!setMethods.containsKey(field.getName())) {          // issue #379 - removed the check for final because JDK 1.5 allows          // modification of final fields through reflection (JSR-133). (JGB)          // pr #16 - final static can only be set by the classloader          int modifiers = field.getModifiers();          if (!(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers))) {            addSetField(field);          }        }        if (!getMethods.containsKey(field.getName())) {          addGetField(field);        }      }    }    if (clazz.getSuperclass() != null) {      addFields(clazz.getSuperclass());    }}</code></pre><p>初始化时，先修改field的访问权限，field.setAccessible(true);即使是private也可以动态修改。所以结果集中的属性即使没有get/set方法，也可以赋值和取值。</p><p><strong>GetFieldInvoker</strong>、<strong>SetFieldInvoker</strong>分别动态设置属性的get、set方法<br><strong>MethodInvoker</strong>执行目标函数的方法</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之动态SQL语句分析</title>
      <link href="/2015/09/28/2.4mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90/"/>
      <url>/2015/09/28/2.4mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="创建动态SQL"><a href="#创建动态SQL" class="headerlink" title="创建动态SQL"></a>创建动态SQL</h1><p>动态SQL作为mybatis最强大的功能之一，比起其他数据层的框架可以在开发中少很多麻烦，再也不用纠结多条件查询等问题了。在最新的mybatis版本，动态标签只有if、choose（when、otherwise）、trim（where、set）、foreach，同时动态标签中还可以使用OGNL表达式进行一些复杂的处理。mybatis生成SQL语句主要类之间的关系如下图所示：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/5-1.png" alt></p><p>通过简单的一条查询语句跟踪，构建动态sql语句大概类之间的依赖关系就差不多明白了。<br>以动态查询SQL为例分析：</p><h2 id="解析xml中的sql标签"><a href="#解析xml中的sql标签" class="headerlink" title="解析xml中的sql标签"></a>解析xml中的sql标签</h2><p>XMLStatementBuilder专门解析mapper.xml文件中的sql语句标签，然后再把这条语句的MappedStatement对象添加到Configuration对象中去。 根据标签中的lang属性，可以用不同的语言去解析sql语句，可以为xml、注解、<a href="https://github.com/mybatis/velocity-scripting" target="_blank" rel="noopener">自定义velocity</a>或者<a href="https://github.com/mybatis/freemarker-scripting" target="_blank" rel="noopener">自定义freemarker</a>解析等等。这里以xml为例，解析sql标签中的sql语句，又有个XMLScriptBuilder来处理，把sql语句中的标签处理完了，一条完整的sql就出来了。<br>根据传入的XNode（sql语句）节点，循环解析XNode的子节点，如果是文本就直接生成StaticTextSqlNode然后传到List<SqlNode>，如果是动态标签还要循序下去，直到没有标签。最终把所有节点存入List<SqlNode>，然后再作为参数传递到MixedSqlNode ，具体的代码实现参考XMLScriptBuilder：</SqlNode></SqlNode></p><pre><code>public SqlSource parseScriptNode() {    List&lt;SqlNode&gt; contents = parseDynamicTags(context);    MixedSqlNode rootSqlNode = new MixedSqlNode(contents);    SqlSource sqlSource = null;    if (isDynamic) {      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);    } else {      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);    }    return sqlSource;}</code></pre><p>这样就获取到DynamicSqlSource了，然后DynamicSqlSource作为参数传递到MappedStatement。<br>参考XMLStatementBuilder的parseStatementNode方法：</p><pre><code>SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</code></pre><h2 id="初始化BoundSql"><a href="#初始化BoundSql" class="headerlink" title="初始化BoundSql"></a>初始化BoundSql</h2><p>解析动态sql语句的时候，只是把标签去除掉了，#{}表达式还是一样在sql语句里面的，这样显然不能执行。mybatis执行器执行sql语句首先从MappedStatement拿到上次构建的动态sql，参考MappedStatement.getBoundSql()，如图所示：</p><p><img src="/images/mybatis/5-2.png" alt></p><p>   直接从DynamicSqlSource入手分析，DynamicSqlSource.getBoundSql(Object parameterObject)方法依赖两个重要的类：<br>1）DynamicContext：保存参数以及拼接SQL语句，ContextMap保存参数，里面使用了MetaObject（防止参数对象里面没有get\set方法）<br>2）SqlSourceBuilder：处理处理占位符和参数<br>3）ParameterMappingTokenHandler：SqlSourceBuilder的内部类，通过工具类GenericTokenParser的解析，构建参数对象ParameterMapping并保存到List列表parameterMappings中，然后将SQL语句中的占位符替换成问号（？）<br>4）StaticSqlSource：动态语句解析后的SqlSource，通过getBoundSql(Object parameterObject)获取到BoundSql<br>最终生成带?占位符的SQL语句。</p><p>针对sql标签中，当个参数时，没有参数标签（如parameterType），只能使用_parameter的原因：<br>判断if标签使用了OGNL表达式，因为实例化DynamicContext的时候，会将参数装进Map里面，默认的键值就为_parameter，在基本类型对象中没有get/set方法获取不到值，然后就去Map中去找key，如果有key值和这个参数对应，就可以继续拼接SQL了，#{_parameter}或者#{id}作为占位符都可以，但是<if test="_parameter != null">标签中只能用_parameter 。在实例化ParameterMappingTokenHandler的时候，将这个参数Map用configuration.newMetaObject(additionalParameters)方法实现用反射的MapWrapper代替原始的参数Map，使用期getGetterType就可以判断参数类型了，然后把参数类型赋值给ParameterMapping的javaType。</if></p><h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><p>参考SimpleExecutor的prepareStatement方法：</p><pre><code>private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {    Statement stmt;    log.debug(&quot;statemet：获取connection连接，如果要打印日志，则返回代理类ConnectionLogger&quot;);    Connection connection = getConnection(statementLog);    stmt = handler.prepare(connection);    log.debug(&quot;statement：参数化把占位符替换成具体值&quot;);    handler.parameterize(stmt);    return stmt;}</code></pre><p>因为是动态SQL，会调用PreparedStatementHandler.parameterize方法，最后由DefaultParameterHandler处理带？的占位符，参考setParameters方法：</p><pre><code>@Overridepublic void setParameters(PreparedStatement ps) throws SQLException {    ErrorContext.instance().activity(&quot;setting parameters&quot;).object(mappedStatement.getParameterMap().getId());    log.debug(&quot;parameter：解析bandSql中的参数并设置到PreparedStatement&quot;);    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();    if (parameterMappings != null) {      for (int i = 0; i &lt; parameterMappings.size(); i++) {        ParameterMapping parameterMapping = parameterMappings.get(i);        if (parameterMapping.getMode() != ParameterMode.OUT) {          Object value;          String propertyName = parameterMapping.getProperty();          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params            value = boundSql.getAdditionalParameter(propertyName);          } else if (parameterObject == null) {            value = null;          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {//如果参数类型在typeHandlerRegistry中能找到，就赋值给value            value = parameterObject;          } else {            MetaObject metaObject = configuration.newMetaObject(parameterObject);            value = metaObject.getValue(propertyName);          }          TypeHandler typeHandler = parameterMapping.getTypeHandler();          JdbcType jdbcType = parameterMapping.getJdbcType();          if (value == null &amp;&amp; jdbcType == null) {            jdbcType = configuration.getJdbcTypeForNull();          }          log.debug(&quot;parametor：这里就是执行类似于自定义自己的typehandler进行参数设置&quot;);          typeHandler.setParameter(ps, i + 1, value, jdbcType);        }      }    }}</code></pre><p>typeHandler.setParameter就是专门处理传入的参数，然后由setNonNullParameter方法将参数值设置到PreparedStatement，这样最终生成的SQL就带?占位符，出入到PreparedStatement就可以执行了。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之执行器分析</title>
      <link href="/2015/09/05/2.3mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%86%E6%9E%90/"/>
      <url>/2015/09/05/2.3mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>不管mybatis还是其他开源项目，只要了解到它的执行流程，再分步骤看代码，思路就变得清晰多了。因为查询要稍微复杂点，就已查询流程为例进行分析。mybatis其实就分两大步骤，第一初始化解析XML，第二执行SQL， 执行器的整个执行的步骤大概如下：<br>SqlSessionFactory-&gt;Configuration-&gt;InterceptorChain-&gt;executor这个过程初始化executor，session-&gt;executor-&gt;cache-&gt;executor-&gt;interceptorChain-&gt;statementhandler（BaseStatementHandler构造函数时，新建ParameterHandler、ResultSetHandler，要经过interceptorChain过滤）-&gt;resultset，类之间的依赖关系如下：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/4-1.png" alt></p><p>执行的时候会先从一级缓存里面去判断是否有值，然后再确定是否重新去数据库查询。再看源代码结构</p><p><img src="/images/mybatis/4-2.png" alt></p><p>从包中的类也可以看出，executor中的类是最多的，算是最核心的模块了，因为通过执行器才能起到承上启下的作用。执行器的继承关系如下图所示：</p><p><img src="/images/mybatis/4-3.png" alt></p><p>Configuration创建executor的时候，参考源代码：</p><pre><code>public Executor newExecutor(Transaction transaction, ExecutorType executorType) {    executorType = executorType == null ? defaultExecutorType : executorType;    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;    Executor executor;    if (ExecutorType.BATCH == executorType) {      executor = new BatchExecutor(this, transaction);    } else if (ExecutorType.REUSE == executorType) {      executor = new ReuseExecutor(this, transaction);    } else {        log.debug(&quot;新建默认执行器，传递configuration对象&quot;);      executor = new SimpleExecutor(this, transaction);    }    if (cacheEnabled) {        //装饰器模式应用，实际动作由SimpleExecutor执行      executor = new CachingExecutor(executor);    }    executor = (Executor) interceptorChain.pluginAll(executor);    return executor;}</code></pre><p>如果配置文件中没有设置是否启用缓存，mybatis默认就启用缓存执行器CachingExecutor。CachingExecutor与SimpleExecutor的最大的区别就是多了一个二级缓存，mapper.xml里面如果没有配置缓存，那么这两个执行器都会使用一级缓存，实例化CachingExecutor函数时，传了SimpleExecutor进去， 其实最终的查询都由SimpleExecutor去执行。参考BaseExecutor代码：</p><pre><code>@Override  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {      log.debug(&quot;executor：获取执行的BoundSQL&quot;);    BoundSql boundSql = ms.getBoundSql(parameter);    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);    return query(ms, parameter, rowBounds, resultHandler, key, boundSql); }  @SuppressWarnings(&quot;unchecked&quot;)  @Override  public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());    if (closed) {      throw new ExecutorException(&quot;Executor was closed.&quot;);    }    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {      clearLocalCache();    }    List&lt;E&gt; list;    try {      queryStack++;      log.debug(&quot;执行查询先从localCache查看是否有缓存&quot;);      list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;      if (list != null) {        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);      } else {        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);      }    } finally {      queryStack--;    }    if (queryStack == 0) {      for (DeferredLoad deferredLoad : deferredLoads) {        deferredLoad.load();      }      // issue #601      deferredLoads.clear();      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {        // issue #482        clearLocalCache();      }    }    return list;  }</code></pre><p>默认就会启用PerpetualCache本地缓存，查看PerpetualCache，其实里面就一个HashMap来缓存结果集，缓存后面会单独分析，这里就不深入研究了。<br>执行器创建完成后，SimpleExecutor底层就由Statement去执行了，和JDBC差不多，设置参数，然后处理结果集了，获取Statement时，这里的设计和Executor几乎差不多的：</p><p><img src="/images/mybatis/4-4.png" alt></p><p>SimpleExecutor在获取Statement之前会先判断静态处理类型、预处理类型还是存储过程，参考Configuration的newStatementHandler方法：</p><pre><code>public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {    log.debug(&quot;statement：新建RoutingStatementHandler&quot;);      StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);    return statementHandler;  }</code></pre><p>实例化RoutingStatementHandler时，就判断是哪种类型，参考源代码：</p><pre><code>public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {      log.debug(&quot;statement：实例化时，从MappedStatement对象判断并分发StatementHandler, 默认为StatementType.PREPARED&quot;);    switch (ms.getStatementType()) {      case STATEMENT:        delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      case PREPARED:        delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      case CALLABLE:        delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);        break;      default:        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());    }}</code></pre><p>如果是预处理的Statement，就实例化PreparedStatementHandler，由于与statement打交道离不开参数与结果集，所以抽象类<br>BaseStatementHandler里面就构造了参数、结果集类的句柄类，代码如下：</p><pre><code>protected BaseStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {    this.configuration = mappedStatement.getConfiguration();    this.executor = executor;    this.mappedStatement = mappedStatement;    this.rowBounds = rowBounds;    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();    this.objectFactory = configuration.getObjectFactory();    if (boundSql == null) { // issue #435, get the key before calculating the statement      generateKeys(parameterObject);      boundSql = mappedStatement.getBoundSql(parameterObject);    }    this.boundSql = boundSql;    log.debug(&quot;handler：初始化解析参数的parameterHandler，执行方法的sql参数传递&quot;);    this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);    log.debug(&quot;handler：初始化结果集处理句柄ResultSetHandler&quot;);    this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);}</code></pre><p>经过判断是哪种Statement之后，SimpleExecutor的prepareStatement方法就开始实例化Statement了，与JDBC步骤差不多，要获取Statement，就<br>先要获取到Connection，在最开始实例化Executor就把transaction传进来了，通过transaction.getConnection();就获取到连接了，然后就通过句柄类StatementHandler的prepare实例化Statement，最后通过Statement或者PreparedStatement执行SQL语句了。参考SimpleExecutor：</p><pre><code>@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {    Statement stmt = null;    try {      Configuration configuration = ms.getConfiguration();      log.debug(&quot;executor: 执行doQuery前新建分发的执行器&quot;);      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);      log.debug(&quot;statement：实例化statement&quot;);      stmt = prepareStatement(handler, ms.getStatementLog());      log.debug(&quot;executor：真正执行查询&quot;);      return handler.&lt;E&gt;query(stmt, resultHandler);    } finally {      closeStatement(stmt);    }    }</code></pre><p>PreparedStatementHandler的执行：</p><pre><code>@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {    PreparedStatement ps = (PreparedStatement) statement;    ps.execute();    log.debug(&quot;statemnt：执行结果集处理&quot;);    return resultSetHandler.&lt;E&gt; handleResultSets(ps);}</code></pre><p>执行完语句客户端最后关闭连接sqlSession.close()，整个执行流程就基本清楚了，后面单独分析如何处理ResultMap，官方文档上面也说了，这个功能很强大，但是也很复杂，参考<a href="http://zeng233.github.io/2015/10/20/8mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BNested%20Select%E3%80%81Nested%20Results%E4%BB%A5%E5%8F%8AN+1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Result Map分析</a>。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之初始化处理</title>
      <link href="/2015/08/25/2.2mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2015/08/25/2.2mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>以初始化xml为例进行分析，SqlSessionFactoryBuilder在执行builder方法的时候，就完成所有的初始化工作，由于初始化阶段，依赖的类很多，还是用类图来描述，初始化配置文件主要的类图如下：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/3-1.png" alt></p><p>mybatis主要有两个配置文件sqlmapConfig.xml以及sqlmap.xml，关于如何用jdk的api去解析xml配置文件的不去分析了，参考XPathParser，解析这两个配置文件的主要类的关系：<br><img src="/images/mybatis/3-2.png" alt></p><p><strong>XMLConfigBuilder</strong><br>处理sqlmapConfig.xml，解析标签并构造Configuration对象，Configuration是mybatis最核心的一个类，全靠它来串联整个执行流程。在实例化XMLConfigBuilder的时候创建它，初始化Configuration时，里面完成了很多与标签相关的类，如对象关系映射的两个类：TypeAliasRegistry（基本类型等别名映射）、TypeHandlerRegistry（结果集映射处理），xml的解析器初始化时也会加载mybatis自定义的DTD文件，xml必须满足DTD的约束才可以，参考XMLMapperEntityResolver类。还记得有次同事用IntelliJ打包部署项目，mybatis配置文件中文注释出现乱码，导致加载的时候出错，当时也没有找到原因，其实只要配置文件符合mybatis-3-config.dtd、mybatis-3-mapper.dtd约束就行了。解析sqlmapConfig.xml部分源代码如下：</p><pre><code>private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {    super(new Configuration());    log.debug(&quot;XMLConfigBuilder构造函数初始化核心对象Configuration&quot;);    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);    this.configuration.setVariables(props);    this.parsed = false;    this.environment = environment;    this.parser = parser;  }  private void parseConfiguration(XNode root) {    try {      //issue #117 read properties first        log.debug(&quot;config.xml：解析各个节点&quot;);      propertiesElement(root.evalNode(&quot;properties&quot;));      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      pluginElement(root.evalNode(&quot;plugins&quot;));      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      settingsElement(root.evalNode(&quot;settings&quot;));      // read it after objectFactory and objectWrapperFactory issue #631      environmentsElement(root.evalNode(&quot;environments&quot;));      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      mapperElement(root.evalNode(&quot;mappers&quot;));    } catch (Exception e) {      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    }  }</code></pre><p><strong>XMLMapperBuilder</strong><br>mapper.xml对应的解析类，解析标签并把解析后的映射对象如cache、parameterMap、resultMap等对象通过MapperBuilderAssistant添加到Configuration。resultMap标签解析比较麻烦，参考<a href="http://zeng233.github.io/2015/10/20/2.7mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BNested%20Select%E3%80%81Nested%20Results%E4%BB%A5%E5%8F%8AN+1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">Nested Results分析</a></p><p><strong>XMLStatementBuilder</strong><br>mapper.xml中包含select|insert|update|delete标签的解析类，标签内的内容构造sql单独由XMLScriptBuilder解析，最终会生成一个MappedStatement，并添加到Configuration。</p><p><strong>MapperBuilderAssistant</strong><br>XMLMapperBuilder的一个辅助类，build开头的方法完成映射（TypeHandler处理），add开头的方法将解析之后的节点添加到Configuration。</p><p><strong>XMLScriptBuilder</strong><br>sql脚本解析类， 主要用于构造sql语句，动态或静态sql的初始化。参考<a href="http://zeng233.github.io/2015/09/28/2.4mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90/">动态SQL分析</a></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码分析之整体架构分析</title>
      <link href="/2015/08/20/2.1mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%89%8D%E8%A8%80/"/>
      <url>/2015/08/20/2.1mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>mybatis虽然设计思路很简单，但是要把内部的一些东西看明白，并不是简单的事情。 空闲之余还了解了下mybatis的<a href="http://blog.mybatis.org/p/about.html" target="_blank" rel="noopener">历史</a>，原来其前身ibatis早在2001年就开始启动了，估计比hibernate还早，2010年脱离了Apache，重新设计的mybatis更加简洁灵活好使。由于mybatis官方并没有给出一个大概的设计图，只有从代码层面入手去分析了，早在Googlecode的时候，mybatis官方还有个大概的映射图，参考如下：</p><a id="more"></a><!-- --- --><p><img src="/images/mybatis/2-1.png" alt="mybatis映射图"></p><p>该图非常简洁明了的说明了mybatis的整体结构，大方向按照这个思路去分析，mybatis的底层实现就明白了。根据上图的理解，mybatis的大概流程就是，初始化配置文件完成文件的解析，然后执行SQL，最后结果集映射处理。通过一段时间的代码阅读，把mybatis源代码各个包之间的关系，画了一个组件图，参考下图：<br><img src="/images/mybatis/2-2.png" alt="包组件图"></p><p>mybatis的主要执行流程如下：<br><img src="/images/mybatis/2-3.png" alt></p><p>从上图也可以看出，mybatis的设计是非常简单的，只要搞明白包之间的关系，分析起来就容易多了。简单说明下各个包主要实现了哪些功能：<br><strong>parsing</strong>：解析xml以及properties文件<br><strong>io</strong>：读取mybatis的配置文件<br><strong>datasource</strong>：mybatis自己实现的数据库连接池<br><strong>builder</strong>：根据sqlmapConfig.xml，sqlmap.xml，初始化SQL执行环境，如实例化Configuration、参数对象、结果集对象等，包含注解与xml两种实现<br><strong>binding</strong>：通过类名+方法名的形式去找到对应的SqlSession方法实现<br><strong>session</strong>：SQL语句执行的入口，主要创建session相关的实现<br><strong>type</strong>：初始化sqlmapConfig.xml的别名注册，以及类型处理注册<br><strong>plugin</strong>：拦截器相关类，要对SQL特殊处理就可以实现该包中的Interceptor，如分页查询<br><strong>executor</strong>：sql执行的核心，获取配置文件的，实现可以执行的sql，最终处理结果集，这些过程都在executor中实现<br><strong>cache</strong>：各种缓存实现<br><strong>mapping</strong>：sqlmapConfig.xml，sqlmap.xml中的标签映射类</p><p>后期会单独对这些核心模块进行分析，以及在实际项目中常见的问题分析，如：执行器流程、动态SQL、事务、缓存、延时加载、批量处理、主键生成策略、读写分离、锁机制等等</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转移托管平台</title>
      <link href="/2014/10/15/0programming%20road1/"/>
      <url>/2014/10/15/0programming%20road1/</url>
      
        <content type="html"><![CDATA[<p>今天看到一条消息<a href="http://www.leiphone.com/news/201410/Qipzs8H8jnnLLrOV.html" target="_blank" rel="noopener">代码托管，哪家强？</a>于是乎想了下还是选择了coding。前几天在微博上面也了解到这个托管平台，但是不知道是什么背景，最担心就是网站不稳定，毕竟国内搞代码托管的最近才兴起，不知道这份热情能持续多久，以前看到<a href="http://www.iteye.com/news/26419" target="_blank" rel="noopener">Teamhost关闭</a>，心里难免有些担忧，但愿coding能坚持发展下去，别让人失望！</p><h4 id="说下选择coding的几个原因"><a href="#说下选择coding的几个原因" class="headerlink" title="说下选择coding的几个原因"></a>说下选择coding的几个原因</h4><ol><li>github有时候访问不稳定，还有被墙的可能性，有时候提交代码感觉像是回到googlecode了，速度让人蛋疼</li><li>看了上面那篇文章的影响，感觉coding的性能各方面还不错，在动态里面也支持markdown</li><li>最近公司也准备换成git管理代码了，也可以拿sourcetree练练手</li></ol><p>暂时就以上3点吧，也希望自己的coding之路坚持下去，”我亦无他，唯手熟尔!”。</p>]]></content>
      
      
      <categories>
          
          <category> programming road </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令操作记录</title>
      <link href="/2014/09/30/1hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2014/09/30/1hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="创建新的MD文件"><a href="#创建新的MD文件" class="headerlink" title="创建新的MD文件"></a>创建新的MD文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>以时间命名文件方便管理</p><p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><!-- --- --><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">或者 hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="发布到远程库"><a href="#发布到远程库" class="headerlink" title="发布到远程库"></a>发布到远程库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>装好deploy插件后，hexo3以上版本支持github http形式的上传，执行hexo命令时，要在git的命令行执行</p><p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> programming road </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
